<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>iOS 中关于列表滚动流畅方案的一些探讨 | 秃头披风侠</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">iOS 中关于列表滚动流畅方案的一些探讨</h1><a id="logo" href="/.">秃头披风侠</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">iOS 中关于列表滚动流畅方案的一些探讨</h1><div class="post-meta">Sep 6, 2017<span> | </span><span class="category"><a href="/categories/iOS/">iOS</a></span></div><a class="disqus-comment-count" data-disqus-identifier="2017/09/06/list_optimize/" href="/2017/09/06/list_optimize/#disqus_thread"></a><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#避免重复多次计算-cell-行高"><span class="toc-text">避免重复多次计算 cell 行高</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#优缺点"><span class="toc-text">优缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文本异步渲染"><span class="toc-text">文本异步渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Frame-搭配异步渲染"><span class="toc-text">Frame 搭配异步渲染</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Auto-Layout-搭配异步渲染"><span class="toc-text">Auto Layout 搭配异步渲染</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#优缺点-1"><span class="toc-text">优缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其它"><span class="toc-text">其它</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#关于圆角"><span class="toc-text">关于圆角</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何定位卡顿原因"><span class="toc-text">如何定位卡顿原因</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li></ol></div></div><div class="post-content"><p>近些年，App 越来越推崇体验至上，随随便便乱写一通的话已经很难让用户买帐了，顺滑的列表便是其中很重要的一点。如果一个 App 的页面滚动起来总是卡顿卡顿的，轻则被当作反面教材来吐槽或者衬托“我们的 App balabala…”，重则直接卸载。正好最近在优化这一块儿，总结记录下。</p>
<p>如果说有什么好的博客文章推荐，ibireme  的  <a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="noopener">iOS 保持界面流畅的技巧</a> 这篇堪称经典，墙裂推荐反复阅读。这篇文章中讲解了很多的优化点，我自己总结了下收益最大的两个优化点：</p>
<ul>
<li>避免重复多次计算 cell 行高</li>
<li>文本异步渲染</li>
</ul>
<p><img src="https://user-gold-cdn.xitu.io/2018/3/6/161fac76c1c09eec?w=2348&amp;h=1012&amp;f=png&amp;s=174882" alt=""></p>
<p>大家可以看看上面这张图的对比分析，数据是 iPhone6 的机子用 instruments 抓的，左边的是用 Auto Layout 绘制界面的数据分析，正常如果想平滑滚动的话，fps 至少需要稳定在 55 左右，我们可以发现，在没有缓存行高和异步渲染的情况下 fps 是最低的，可以说是比较卡顿了，至少是能肉眼感觉出来，能满足平滑滚动要求的也只有在缓存行高且异步渲染的情况下；右边的是没用 Auto Layout 直接用 frame 来绘制界面的数据分析，可以发现即使没有异步渲染，也能勉强满足平滑滚动的要求，如果开启异步渲染的话，可以说是相当的丝滑了。</p>
<h3 id="避免重复多次计算-cell-行高"><a href="#避免重复多次计算-cell-行高" class="headerlink" title="避免重复多次计算 cell 行高"></a>避免重复多次计算 cell 行高</h3><p>TableView 行高计算可以说是个老生常谈的问题了，<code>heightForRowAtIndexPath:</code>  是个调用相当频繁的方法，在里面做过多的事情难免会造成卡顿。 在 iOS 8 中，我们可以通过设置下面两个属性来很轻松的实现高度自适应：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.tableView.estimatedRowHeight = <span class="number">88</span>;</span><br><span class="line"><span class="keyword">self</span>.tableView.rowHeight = <span class="built_in">UITableViewAutomaticDimension</span>;</span><br></pre></td></tr></table></figure>
<p>虽然很方便，不过如果你的页面对性能有一定要求，建议不要这么做，具体可以看看 sunnyxx 的 <a href="http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/" target="_blank" rel="noopener">优化UITableViewCell高度计算的那些事</a>。文中针对 Auto Layout，提供了个 cell 行高的缓存库 <a href="https://github.com/forkingdog/UITableView-FDTemplateLayoutCell" target="_blank" rel="noopener">UITableView-FDTemplateLayoutCell</a>，可以很好的帮助我们避免 cell 行高多次计算的问题。</p>
<p>如果不使用 Auto Layout，我们可以在请求完拿到数据后提前计算好页面每个控件的 frame 和 cell 高度，并且缓存在内存中，用的时候直接在 <code>heightForRowAtIndexPath:</code> 取出计算好的值就行，大概流程如下：</p>
<ul>
<li>模拟请求数据回调：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">[<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span> buildTestDataThen:^(<span class="built_in">NSMutableArray</span> &lt;FDFeedEntity *&gt; *entities) &#123;</span><br><span class="line"><span class="keyword">self</span>.data = @[].mutableCopy;</span><br><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (FDFeedEntity *entity <span class="keyword">in</span> entities) &#123;</span><br><span class="line">FrameModel *frameModel = [FrameModel new];</span><br><span class="line">frameModel.entity = entity;</span><br><span class="line">[<span class="keyword">self</span>.data addObject:frameModel];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">[<span class="keyword">self</span>.tvFeed reloadData];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>一个简单计算 frame 、cell 行高方式：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FrameModel.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">FrameModel</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CGRect</span> titleFrame;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CGFloat</span> cellHeight;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) FDFeedEntity *entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FrameModel.m</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">FrameModel</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setEntity:(FDFeedEntity *)entity &#123;</span><br><span class="line"><span class="keyword">if</span> (!entity) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">_entity = entity;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CGFloat</span> maxLayout = ([<span class="built_in">UIScreen</span> mainScreen].bounds.size.width - <span class="number">20.</span>f);</span><br><span class="line"><span class="built_in">CGFloat</span> bottom = <span class="number">4.</span>f;</span><br><span class="line"></span><br><span class="line"><span class="comment">//title</span></span><br><span class="line"><span class="built_in">CGFloat</span> titleX = <span class="number">10.</span>f;</span><br><span class="line"><span class="built_in">CGFloat</span> titleY = <span class="number">10.</span>f;</span><br><span class="line"><span class="built_in">CGSize</span> titleSize = [entity.title boundingRectWithSize:<span class="built_in">CGSizeMake</span>(maxLayout, <span class="built_in">CGFLOAT_MAX</span>) options:<span class="built_in">NSStringDrawingUsesLineFragmentOrigin</span>|<span class="built_in">NSStringDrawingUsesFontLeading</span> attributes:@&#123;<span class="built_in">NSFontAttributeName</span> : Font(<span class="number">16.</span>f)&#125; context:<span class="literal">nil</span>].size;</span><br><span class="line">_titleFrame = <span class="built_in">CGRectMake</span>(titleX, titleY, titleSize.width, titleSize.height);</span><br><span class="line"></span><br><span class="line"><span class="comment">//cell Height</span></span><br><span class="line">_cellHeight = (<span class="built_in">CGRectGetMaxY</span>(_titleFrame) + bottom);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<ul>
<li>行高取值：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">UITableViewCell</span> *)tableView:(<span class="built_in">UITableView</span> *)tableView cellForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">FrameFeedCell *cell = [tableView dequeueReusableCellWithIdentifier:FrameFeedCellIdentifier forIndexPath:indexPath];</span><br><span class="line">FrameModel *frameModel = <span class="keyword">self</span>.data[indexPath.row];</span><br><span class="line">cell.model = frameModel;</span><br><span class="line"><span class="keyword">return</span> cell;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">FrameModel *frameModel = <span class="keyword">self</span>.data[indexPath.row];</span><br><span class="line"><span class="keyword">return</span> frameModel.cellHeight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>控件赋值：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setModel:(FrameModel *)model &#123;</span><br><span class="line"><span class="keyword">if</span> (!model) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">_model = model;</span><br><span class="line"></span><br><span class="line">FDFeedEntity *entity = model.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span>.titleLabel.frame = model.titleFrame;</span><br><span class="line"><span class="keyword">self</span>.titleLabel.text = entity.title;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>缓存行高方式有现成的库简单方便，虽然 UITableView-FDTemplateLayoutCell 已经处理的很好了，但是 Auto Layout 对性能还是会有部分消耗；手动计算 frame 方式所有的位置都需要计算，比较麻烦，而且在数据量很大的情况下，大量的计算对数据展示时间会有部分影响，相应的回报就是性能会更好一些。</p>
<h3 id="文本异步渲染"><a href="#文本异步渲染" class="headerlink" title="文本异步渲染"></a>文本异步渲染</h3><p>当显示大量文本时，CPU 的压力会非常大。对此解决方案只有一个，那就是自定义文本控件，用 TextKit 或最底层的 CoreText 对文本异步绘制。尽管这实现起来非常麻烦，但其带来的优势也非常大，CoreText 对象创建好后，能直接获取文本的宽高等信息，避免了多次计算（调整 UILabel 大小时算一遍、UILabel 绘制时内部再算一遍）；CoreText 对象占用内存较少，可以缓存下来以备稍后多次渲染。</p>
<p>幸运的是，想支持文本异步渲染也有现成的库 <a href="https://github.com/ibireme/YYText" target="_blank" rel="noopener">YYText</a> ，下面来讲讲如何搭配它最大程度满足我们如丝般顺滑的需求：</p>
<h4 id="Frame-搭配异步渲染"><a href="#Frame-搭配异步渲染" class="headerlink" title="Frame 搭配异步渲染"></a>Frame 搭配异步渲染</h4><p>基本思路和计算 frame 类似，只不过把系统的 <code>boundingRectWithSize:</code>、 <code>sizeWithAttributes:</code> 换成  YYText  中的方法：</p>
<ul>
<li>配置 frame model：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FrameYYModel.h</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">FrameYYModel</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CGRect</span> titleFrame;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) YYTextLayout *titleLayout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CGFloat</span> cellHeight;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) FDFeedEntity *entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//FrameYYModel.m</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">FrameYYModel</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setEntity:(FDFeedEntity *)entity &#123;</span><br><span class="line"><span class="keyword">if</span> (!entity) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">_entity = entity;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CGFloat</span> maxLayout = ([<span class="built_in">UIScreen</span> mainScreen].bounds.size.width - <span class="number">20.</span>f);</span><br><span class="line"><span class="built_in">CGFloat</span> space = <span class="number">10.</span>f;</span><br><span class="line"><span class="built_in">CGFloat</span> bottom = <span class="number">4.</span>f;</span><br><span class="line"></span><br><span class="line"><span class="comment">//title</span></span><br><span class="line"><span class="built_in">NSMutableAttributedString</span> *title = [[<span class="built_in">NSMutableAttributedString</span> alloc] initWithString:entity.title];</span><br><span class="line">title.yy_font = Font(<span class="number">16.</span>f);</span><br><span class="line">title.yy_color = [<span class="built_in">UIColor</span> blackColor];</span><br><span class="line"></span><br><span class="line">YYTextContainer *titleContainer = [YYTextContainer containerWithSize:<span class="built_in">CGSizeMake</span>(maxLayout, <span class="built_in">CGFLOAT_MAX</span>)];</span><br><span class="line">_titleLayout = [YYTextLayout layoutWithContainer:titleContainer text:title];</span><br><span class="line"></span><br><span class="line"><span class="built_in">CGFloat</span> titleX = <span class="number">10.</span>f;</span><br><span class="line"><span class="built_in">CGFloat</span> titleY = <span class="number">10.</span>f;</span><br><span class="line"><span class="built_in">CGSize</span> titleSize = _titleLayout.textBoundingSize;</span><br><span class="line">_titleFrame = (<span class="built_in">CGRect</span>)&#123;titleX,titleY,<span class="built_in">CGSizeMake</span>(titleSize.width, titleSize.height)&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cell Height</span></span><br><span class="line">_cellHeight = (<span class="built_in">CGRectGetMaxY</span>(_titleFrame) + bottom);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>对比上面 frame，可以发现多了个 <code>YYTextLayout</code>  属性，这个属性可以提前配置文本的特性，包括 <code>font</code>、<code>textColor</code> 以及行数、行间距、内间距等等，好处就是可以把一些逻辑提前处理好，比如根据接口字段，动态配置字体颜色，字号等，如果用 Auto Layout，这部分逻辑则不可避免的需要写在  <code>cellForRowAtIndexPath:</code> 方法中。</p>
<ul>
<li>UITableViewCell 处理 ：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithStyle:(<span class="built_in">UITableViewCellStyle</span>)style reuseIdentifier:(<span class="built_in">NSString</span> *)reuseIdentifier &#123;</span><br><span class="line"><span class="keyword">self</span> = [<span class="keyword">super</span> initWithStyle:style reuseIdentifier:reuseIdentifier];</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">self</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">YYLabel *title = [YYLabel new];</span><br><span class="line">title.displaysAsynchronously = <span class="literal">YES</span>; <span class="comment">//开启异步渲染</span></span><br><span class="line">title.ignoreCommonProperties = <span class="literal">YES</span>; <span class="comment">//忽略属性</span></span><br><span class="line">title.layer.borderColor = [<span class="built_in">UIColor</span> brownColor].CGColor;</span><br><span class="line">title.layer.cornerRadius = <span class="number">1.</span>f;</span><br><span class="line">title.layer.borderWidth = <span class="number">1.</span>f;</span><br><span class="line">[<span class="keyword">self</span>.contentView addSubview:_titleLabel = title];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>赋值：</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setModel:(FrameYYModel *)model &#123;</span><br><span class="line"><span class="keyword">if</span> (!model) <span class="keyword">return</span>;</span><br><span class="line">_model = model;</span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span>.titleLabel.frame = model.titleFrame;</span><br><span class="line"><span class="keyword">self</span>.titleLabel.textLayout = model.titleLayout; <span class="comment">//直接取 YYTextLayout</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Auto-Layout-搭配异步渲染"><a href="#Auto-Layout-搭配异步渲染" class="headerlink" title="Auto Layout 搭配异步渲染"></a>Auto Layout 搭配异步渲染</h4><p>YYText  非常友好，同样支持 xib，YYText  继承自 <code>UIView</code>，所要做的事情也很简单：</p>
<ul>
<li>在 xib 中配置约束</li>
<li>开启异步属性</li>
</ul>
<p>开启异步属性可以代码里设置，也可以直接在 xib 里设置，分别如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.titleLabel.displaysAsynchronously = <span class="literal">YES</span>;</span><br><span class="line"><span class="keyword">self</span>.subTitleLabel.displaysAsynchronously = <span class="literal">YES</span>;</span><br><span class="line"><span class="keyword">self</span>.contentLabel.displaysAsynchronously = <span class="literal">YES</span>;</span><br><span class="line"><span class="keyword">self</span>.usernameLabel.displaysAsynchronously = <span class="literal">YES</span>;</span><br><span class="line"><span class="keyword">self</span>.timeLabel.displaysAsynchronously = <span class="literal">YES</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://user-gold-cdn.xitu.io/2018/3/6/161fac82e73d6b34?w=359&amp;h=111&amp;f=png&amp;s=11362" alt=""></p>
<p>另外需要注意的一点是，多行文本的情况下需要设置最大换行宽：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGFloat</span> maxLayout = [<span class="built_in">UIScreen</span> mainScreen].bounds.size.width - <span class="number">20.</span>f;</span><br><span class="line"><span class="keyword">self</span>.titleLabel.preferredMaxLayoutWidth = maxLayout;</span><br><span class="line"><span class="keyword">self</span>.subTitleLabel.preferredMaxLayoutWidth = maxLayout;</span><br><span class="line"><span class="keyword">self</span>.contentLabel.preferredMaxLayoutWidth = maxLayout;</span><br></pre></td></tr></table></figure>
<h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><p>YYText 的异步渲染能极大程度的提高列表流畅度，真正达到如丝般顺滑，但是在开启异步时，刷新列表会有闪烁情况，仔细想想觉得也正常，毕竟是异步的，渲染也需要时间，这里作者给出了一些 <a href="https://github.com/ibireme/YYKit/issues/64" target="_blank" rel="noopener">方案</a>，大家可以看看。</p>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><h4 id="关于圆角"><a href="#关于圆角" class="headerlink" title="关于圆角"></a>关于圆角</h4><p>列表中如果存在很多系统设置的圆角页面导致卡顿：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">label.layer.cornerRadius = <span class="number">5.</span>f;</span><br><span class="line">label.clipsToBounds = <span class="literal">YES</span>;</span><br></pre></td></tr></table></figure>
<p>据观察，只要当前屏幕内只要设置圆角的控件个数不要太多（大概十几个算个临界点），就不会引起卡顿。</p>
<p>还有就是只要不设置 <code>clipsToBounds</code> 不管多少个，都不会卡顿，比如你需要圆角的控件是白色背景色的，然后它的父控件也是白色背景色的，而且没有点击后高亮的，就没必要 clipsToBounds 了。</p>
<h4 id="如何定位卡顿原因"><a href="#如何定位卡顿原因" class="headerlink" title="如何定位卡顿原因"></a>如何定位卡顿原因</h4><p>我们可以利用 instruments 中的 Time Profiler 来帮助我们定位问题位置，选中 Xcode，command + control + i  打开：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/3/6/161fad0ac4b089d3?w=621&amp;h=411&amp;f=gif&amp;s=2330429" alt=""></p>
<p>我们选中主线程，去掉系统的方法，然后操作一下列表，再截取一段调用信息，可以发现我们自己实现的方法并没有消耗多少时间，反而是系统的方法很费时，这也是卡顿的原因之一：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/3/6/161fac8e6636c45b?w=2556&amp;h=1126&amp;f=png&amp;s=833508" alt=""></p>
<p>另外有的人 instruments 看不到方法调用栈（右边一对黑色的方法信息），去 Xcode 设置下就行了：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/3/6/161fac90beed541d?w=1870&amp;h=498&amp;f=png&amp;s=122024" alt=""></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>YYText 和 UITableView-FDTemplateLayoutCell 搭配可以很大程度的提高列表流畅度：</p>
<ul>
<li><p><strong>如果时间比较紧迫，可以直接采取 Auto Layout + UITableView-FDTemplateLayoutCell + YYText 方式</strong></p>
</li>
<li><p><strong>如果列表中文本不包含富文本，仅仅显示文字，又不想引入这两个库，可以使用系统方式提前计算 Frame</strong></p>
</li>
<li><p><strong>如果想最大程度的流畅度，就需要提前计算 Frame + YYText，具体大家根据自己情况选择合适的方案就行</strong></p>
</li>
</ul>
</div><iframe src="/donate/?AliPayQR=/img/AliPay.png&amp;WeChatQR=/img/WechatPay.png&amp;GitHub=null&amp;BTCQR=null&amp;BTCKEY=null&amp;PayPal=null" style="overflow-x:hidden; overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;" frameborder="0" scrolling="no"></iframe><div class="tags"></div><div class="post-nav"><a class="pre" href="/2017/11/06/responder_chain/">基于 ResponderChain 的对象交互方式</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'http://yoursite.com/2017/09/06/list_optimize/';
    this.page.identifier = '2017/09/06/list_optimize/';
    this.page.title = 'iOS 中关于列表滚动流畅方案的一些探讨';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//leeeisok.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//leeeisok.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://leeeisok.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });
</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Swift/">Swift</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/总结/">总结</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/12/27/2018_questioning/">2018 年度总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/19/message_forward/">iOS 消息发送与转发详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/24/log_analysis/">iOS crash 日志堆栈解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/06/self_release/">聊聊 iOS 中的自释放</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/13/swift_tips/">Swift 小知识点</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/06/responder_chain/">基于 ResponderChain 的对象交互方式</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/06/list_optimize/">iOS 中关于列表滚动流畅方案的一些探讨</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//leeeisok.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">秃头披风侠.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>