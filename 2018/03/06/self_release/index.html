<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>聊聊 iOS 中的自释放 | 秃头披风侠</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">聊聊 iOS 中的自释放</h1><a id="logo" href="/.">秃头披风侠</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">聊聊 iOS 中的自释放</h1><div class="post-meta">Mar 6, 2018<span> | </span><span class="category"><a href="/categories/iOS/">iOS</a></span></div><a class="disqus-comment-count" data-disqus-identifier="2018/03/06/self_release/" href="/2018/03/06/self_release/#disqus_thread"></a><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#对象内存的回收"><span class="toc-text">对象内存的回收</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#KVO-的自释放"><span class="toc-text">KVO 的自释放</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FBKVOController"><span class="toc-text">FBKVOController</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReactiveCocoa"><span class="toc-text">ReactiveCocoa</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NSNotification-的自释放"><span class="toc-text">NSNotification 的自释放</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NSTimer-的自释放"><span class="toc-text">NSTimer 的自释放</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#YYWeakProxy"><span class="toc-text">YYWeakProxy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#YYTimer"><span class="toc-text">YYTimer</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-text">参考</span></a></li></ol></div></div><div class="post-content"><p>什么叫自释放？可以简单的理解为：对象在生命周期结束后，自动清理回收与其相关的资源。这个清理不仅仅包括对象内存的回收，还包括对象解耦及附属事件的清理等等，例如定时器的停止、通知以及 KVO 对象的监听移除。</p>
<h2 id="对象内存的回收"><a href="#对象内存的回收" class="headerlink" title="对象内存的回收"></a>对象内存的回收</h2><p>在开发中，对象管理的基本原则 — 谁创建谁释放。但是在 MRC 中，我们会用 <code>autorelease</code> 来标记一个对象，告诉编辑器，这个对象我不负责释放。<strong>此时，这个对象就变成了自释放的对象，当其不再需要时，系统就会自动回收其内存。</strong> 等到了 ARC 时代，基本上所有对象对于我们来说都是自释放对象，我们不需要再处处留意内存泄漏问题，可以更专注于业务逻辑上。</p>
<h2 id="KVO-的自释放"><a href="#KVO-的自释放" class="headerlink" title="KVO 的自释放"></a>KVO 的自释放</h2><p>iOS 开发中，我们使用 KVO 监听对象某个 <code>keyPath</code> 时，需要在<strong>被监听的对象释放前</strong>移除对应的 <code>keyPath</code> 监听：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Person *person = [Person new];</span><br><span class="line"><span class="keyword">self</span>.person = person;</span><br><span class="line">[<span class="keyword">self</span>.person addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"name"</span> options:<span class="built_in">NSKeyValueObservingOptionOld</span> | <span class="built_in">NSKeyValueObservingOptionNew</span> context:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">	[<span class="keyword">self</span>.person removeObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"name"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们一不小心忘了移除对应的监听，会得到这样的错误：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Terminating app due to uncaught exception 'NSInternalInconsistencyException', reason: 'An instance 0x17000c2c0 of class Person was deallocated while key value observers were still registered with it. Current observation info: &lt;NSKeyValueObservationInfo 0x17003c9e0&gt;(</span><br><span class="line">&lt;<span class="built_in">NSKeyValueObservance</span> <span class="number">0x170243de0</span>: Observer: <span class="number">0x129d053b0</span>, Key path: name, Options: &lt;New: <span class="literal">YES</span>, Old: <span class="literal">YES</span>, Prior: <span class="literal">NO</span>&gt; Context: <span class="number">0x0</span>, Property: <span class="number">0x170243db0</span>&gt;)<span class="string">'</span></span><br></pre></td></tr></table></figure>
<h3 id="FBKVOController"><a href="#FBKVOController" class="headerlink" title="FBKVOController"></a>FBKVOController</h3><p>我们不由的产生疑问： 对象的 <code>dealloc</code> 函数只做了<code>removeObserver:forKeyPath:</code> 一件事，能不能不每次都写呢？<a href="https://github.com/facebook/KVOController" target="_blank" rel="noopener">FBKVOController</a> 也许会是一个不错的选择：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Person *person = [Person new];</span><br><span class="line"><span class="keyword">self</span>.person = person;</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span>.KVOController observe:person keyPath:<span class="string">@"name"</span> options:<span class="built_in">NSKeyValueObservingOptionOld</span> | <span class="built_in">NSKeyValueObservingOptionNew</span> block:^(<span class="keyword">id</span>  _Nullable observer, <span class="keyword">id</span>  _Nonnull object, <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; * _Nonnull change) &#123;</span><br><span class="line">	<span class="built_in">NSString</span> *new = change[<span class="built_in">NSKeyValueChangeNewKey</span>];</span><br><span class="line">	<span class="built_in">NSString</span> *old = change[<span class="built_in">NSKeyValueChangeOldKey</span>];</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"%@  %@"</span>,new,old);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>抛开烦人的 <code>removeObserver:forKeyPath:</code>，更加简明清晰的满足了需求。</p>
<p>那么，<a href="https://github.com/facebook/KVOController" target="_blank" rel="noopener">FBKVOController</a>  是如何做到自释放的呢？<strong>其内部将观察者绑定到 <code>FBKVOController</code> 这个第三者上，<code>FBKVOController</code> 会随着观察者的释放而释放。最后，<code>FBKVOController</code> 在自己的 <code>dealloc</code> 方法中，通过 <code>_FBKVOSharedController</code> 这个单例来移除监听。</strong></p>
<h3 id="ReactiveCocoa"><a href="#ReactiveCocoa" class="headerlink" title="ReactiveCocoa"></a>ReactiveCocoa</h3><p>除了 FBKVOController，<a href="https://github.com/ReactiveCocoa/ReactiveObjC/tree/3.1.0" target="_blank" rel="noopener">ReactiveCocoa</a> 也同样支持 KVO 的自释放：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Person *person = [Person new];</span><br><span class="line"><span class="keyword">self</span>.person = person;</span><br><span class="line"></span><br><span class="line">[[<span class="keyword">self</span>.person rac_valuesAndChangesForKeyPath:<span class="string">@"name"</span>  options:<span class="built_in">NSKeyValueObservingOptionOld</span> | <span class="built_in">NSKeyValueObservingOptionNew</span>  observer:<span class="keyword">self</span>] subscribeNext:^(RACTwoTuple&lt;<span class="keyword">id</span>,<span class="built_in">NSDictionary</span> *&gt; * _Nullable x) &#123;</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"%@ %@"</span>,x.second[<span class="string">@"old"</span>],x.second[<span class="string">@"new"</span>]);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>ReactiveCocoa 和 FBKVOController 略有不同，ReactiveCocoa 是通过<strong>监听观察者的 <code>dealloc</code> 方法</strong>，并通过 <code>RACKVOTrampoline</code> 这个对象来管理对象 KVO 监听的添加/移除。</p>
<blockquote>
<p>⚠️ 经测试，在 iOS 11 中，系统已经帮我们做了 KVO 的 <code>keyPath</code> 移除操作。遗憾的是，iOS 11 以下，不移除仍然存在问题！</p>
</blockquote>
<h2 id="NSNotification-的自释放"><a href="#NSNotification-的自释放" class="headerlink" title="NSNotification 的自释放"></a>NSNotification 的自释放</h2><p>通常，我们使用通知时是这样的：</p>
 <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加</span></span><br><span class="line">[[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span>  selector:<span class="keyword">@selector</span>(respondsToNotification:) name:<span class="string">@"test0"</span> object:<span class="literal">nil</span>];</span><br><span class="line"><span class="comment">// 发送</span></span><br><span class="line">[[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:<span class="string">@"test0"</span> object:<span class="literal">nil</span>];</span><br><span class="line"><span class="comment">// 移除</span></span><br><span class="line">[[<span class="built_in">NSNotificationCenter</span> defaultCenter] removeObserver:<span class="keyword">self</span> name:<span class="string">@"test0"</span> object:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>
<p>关于移除操作，根据不同的业务场景，有的是放在 <code>dealloc</code> 方法中，有的是 <code>viewWillDisappear:</code> 方法中。然而，在 iOS 8 及以上版本中，我们已经不需要再手动移除通知了，大家可以用以下代码测试下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">NSNotificationCenter</span> (<span class="title">NS</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">	Method origin = class_getInstanceMethod([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(removeObserver:));</span><br><span class="line">	Method current = class_getInstanceMethod([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(_removeObserver:));</span><br><span class="line">	method_exchangeImplementations(origin, current);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)_removeObserver:(<span class="keyword">id</span>)observer &#123;</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"调用移除通知方法: %@"</span>, observer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>这应该是苹果在 iOS 11  中的一次优化。</p>
<h2 id="NSTimer-的自释放"><a href="#NSTimer-的自释放" class="headerlink" title="NSTimer 的自释放"></a>NSTimer 的自释放</h2><p>通常我们是这样使用定时器：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSTimer</span> *timer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span>.timer = [<span class="built_in">NSTimer</span> scheduledTimerWithTimeInterval:<span class="number">1.0</span>f target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(timerTest) userInfo:<span class="literal">nil</span> repeats:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure>
<p>定时器<strong>内部</strong>会 <code>strong</code>  <code>target</code>，而 <code>self</code> 也就是 <code>target</code> 又 <code>strong</code> 了定时器，这样就造成了循环引用，导致 <code>self</code> 无法释放。想要打破，我们只有<strong>主动</strong>调用 <code>invalidate</code> 方法。目前解决这种问题的方法有两种方式：</p>
<ul>
<li>使用 <code>weak proxy</code>，持有弱引用 <code>target</code> ，转发消息到 <code>target</code>。<a href="https://github.com/ibireme/YYKit/blob/master/YYKit/Utility/YYWeakProxy.h" target="_blank" rel="noopener">YYWeakProxy</a> 是个不错的选择。</li>
<li>使用 <code>dispatch_source</code> 自己实现一个定时器。<a href="https://github.com/ibireme/YYKit/blob/master/YYKit/Utility/YYTimer.h" target="_blank" rel="noopener">YYTimer</a> 是个不错的选择。</li>
</ul>
<h3 id="YYWeakProxy"><a href="#YYWeakProxy" class="headerlink" title="YYWeakProxy"></a>YYWeakProxy</h3><p>YYWeakProxy 是 NSProxy 的子类，其内持有了 <code>weak</code> <code>target</code>，利用消息转发机制，将消息转发到传进来的 <code>target</code>：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nullable</span>, <span class="keyword">nonatomic</span>, <span class="keyword">weak</span>, <span class="keyword">readonly</span>) <span class="keyword">id</span> target;</span><br></pre></td></tr></table></figure>
<p>这样，当 <code>self</code> 引用计数为 <code>0</code> 时，<code>target</code> 将为 <code>nil</code>，这样就打破了 <code>self</code> 和 <code>NSTimer</code> 之间的循环引用，<code>self</code> 也就得以释放。</p>
<p>然而，虽然 <code>self</code> 和 <code>NSTimer</code> 之间循环引用打破了，却又造成了 <code>YYWeakProxy</code> 和 <code>NSTimer</code> 之间的循环引用，导致 <code>YYWeakProxy</code> 的内存泄漏。按照作者的意思，与其泄漏一个可能很重的 <code>self</code>，不如泄漏一个轻量的 <code>YYWeakProxy</code>。</p>
<h3 id="YYTimer"><a href="#YYTimer" class="headerlink" title="YYTimer"></a>YYTimer</h3><p>YYTimer 可以彻底的解决内存泄漏问题，缺点是实现相对复杂。 其内部是使用 GCD 的 <code>dispatch_source</code> 来实现的，关于 <code>dispatch_source</code> 使用如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 队列</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue();</span><br><span class="line"><span class="comment">// 创建 dispatch_source</span></span><br><span class="line">dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, queue);</span><br><span class="line"><span class="comment">// 声明成员变量</span></span><br><span class="line"><span class="keyword">self</span>.timer = timer;</span><br><span class="line"><span class="comment">// 设置两秒后触发</span></span><br><span class="line">dispatch_time_t startTime = dispatch_time(DISPATCH_TIME_NOW, <span class="number">3.0</span> * <span class="built_in">NSEC_PER_SEC</span>);</span><br><span class="line"><span class="comment">// 设置下次触发事件为 DISPATCH_TIME_FOREVER</span></span><br><span class="line">dispatch_time_t nextTime = DISPATCH_TIME_FOREVER;</span><br><span class="line"><span class="comment">// 设置精确度</span></span><br><span class="line">dispatch_time_t leeway = <span class="number">0.1</span> * <span class="built_in">NSEC_PER_SEC</span>;</span><br><span class="line"><span class="comment">// 配置时间</span></span><br><span class="line">dispatch_source_set_timer(timer, startTime, nextTime, leeway);</span><br><span class="line"><span class="comment">// 回调</span></span><br><span class="line">dispatch_source_set_event_handler(timer, ^&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 激活</span></span><br><span class="line">dispatch_resume(timer);</span><br></pre></td></tr></table></figure>
<p>需要取消的话：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatch_source_cancel(<span class="keyword">self</span>.timer);</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.olinone.com/?p=232" target="_blank" rel="noopener">http://www.olinone.com/?p=232</a></p>
</div><iframe src="/donate/?AliPayQR=/img/AliPay.png&amp;WeChatQR=/img/WechatPay.png&amp;GitHub=null&amp;BTCQR=null&amp;BTCKEY=null&amp;PayPal=null" style="overflow-x:hidden; overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;" frameborder="0" scrolling="no"></iframe><div class="tags"></div><div class="post-nav"><a class="pre" href="/2018/04/24/log_analysis/">iOS crash 日志堆栈解析</a><a class="next" href="/2018/02/13/swift_tips/">Swift 小知识点</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'http://yoursite.com/2018/03/06/self_release/';
    this.page.identifier = '2018/03/06/self_release/';
    this.page.title = '聊聊 iOS 中的自释放';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//leeeisok.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//leeeisok.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://leeeisok.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });
</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Swift/">Swift</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/思考/">思考</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/总结/">总结</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/05/24/competition_analysis/">competition_analysis</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/01/trainingday/">影片《训练日》-- 观后感</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/27/2018_questioning/">2018 年度总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/19/message_forward/">iOS 消息发送与转发详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/24/log_analysis/">iOS crash 日志堆栈解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/06/self_release/">聊聊 iOS 中的自释放</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/13/swift_tips/">Swift 小知识点</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/06/responder_chain/">基于 ResponderChain 的对象交互方式</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/06/list_optimize/">iOS 中关于列表滚动流畅方案的一些探讨</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//leeeisok.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">秃头披风侠.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>