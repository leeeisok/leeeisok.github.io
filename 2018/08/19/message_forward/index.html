<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>iOS 消息发送与转发详解 | 秃头披风侠</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">iOS 消息发送与转发详解</h1><a id="logo" href="/.">秃头披风侠</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">iOS 消息发送与转发详解</h1><div class="post-meta">Aug 19, 2018<span> | </span><span class="category"><a href="/categories/iOS/">iOS</a></span></div><a class="disqus-comment-count" data-disqus-identifier="2018/08/19/message_forward/" href="/2018/08/19/message_forward/#disqus_thread"></a><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#消息发送"><span class="toc-text">消息发送</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Runtime-是如何找到实例方法的具体实现的？"><span class="toc-text">Runtime 是如何找到实例方法的具体实现的？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#基础概念"><span class="toc-text">基础概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#寻找流程"><span class="toc-text">寻找流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类对象的类方法又是怎么找到并执行的？"><span class="toc-text">类对象的类方法又是怎么找到并执行的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何提高方法查找的效率？"><span class="toc-text">如何提高方法查找的效率？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关于父类（superclass）"><span class="toc-text">关于父类（superclass）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#消息转发"><span class="toc-text">消息转发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#第一次"><span class="toc-text">第一次</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第二次"><span class="toc-text">第二次</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第三次"><span class="toc-text">第三次</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li></ol></div></div><div class="post-content"><p>Objective-C 是一门动态语言，它将很多静态语言在编译和链接时期做的事情，放到了运行时来处理。之所以能具备这种特性，离不开 Runtime 这个库。Runtime 很好的解决了如何在运行时期找到调用方法这样的问题。</p>
<h2 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h2><p>在 Objective-C 中，方法调用称为<strong>向对象发送消息</strong>：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyClass 类</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span>: <span class="title">NSObject</span></span></span><br><span class="line">- (<span class="keyword">void</span>)printLog;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span></span></span><br><span class="line">- (<span class="keyword">void</span>)printLog &#123;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"print log !"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">MyClass *myClass = [[MyClass alloc] init];</span><br><span class="line">[myClass printLog];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出： print log !</span></span><br></pre></td></tr></table></figure>
<p>上面代码中的 <code>[myClass printLog]</code> 也可以这么写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL))(<span class="keyword">void</span> *) objc_msgSend)(myClass, <span class="keyword">@selector</span>(printLog));</span><br></pre></td></tr></table></figure>
<p><code>[myClass printLog]</code> 经过编译后就是调用 <code>objc_msgSend</code> 方法。</p>
<p>我们看看这个方法的文档定义：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> objc_msgSend(<span class="keyword">id</span> <span class="keyword">self</span>, SEL op, ...);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>self：消息的接收者<br>op： 消息的方法名，C 字符串<br>… ：参数列表</p>
</blockquote>
<h3 id="Runtime-是如何找到实例方法的具体实现的？"><a href="#Runtime-是如何找到实例方法的具体实现的？" class="headerlink" title="Runtime 是如何找到实例方法的具体实现的？"></a>Runtime 是如何找到实例方法的具体实现的？</h3><h4 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h4><p>讲之前，我们需要先明白一些基础概念：Objective-C 是一门面向对象的语言，对象又分为<strong>实例对象</strong>、<strong>类对象</strong>、<strong>元类对象</strong>以及<strong>根元类对象</strong>。它们是通过一个叫 <code>isa</code> 的指针来关联起来，具体关系如下图：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/3/13/1621e9a878046e51?w=625&amp;h=656&amp;f=png&amp;s=162531" alt=""></p>
<p>以我们上文的代码为例：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyClass *myClass = [[MyClass alloc] init];</span><br></pre></td></tr></table></figure>
<p>整理下相互间的关系：</p>
<ul>
<li><code>myClass</code> 是实例对象</li>
<li><code>MyClass</code> 是类对象</li>
<li><code>MyClass</code> 的元类的元类就是 <code>NSObject</code> 的元类</li>
<li><code>NSObject</code> 就是 Root class (class)</li>
<li><code>NSObject</code> 的 <code>superclass</code> 为 <code>nil</code></li>
<li><code>NSObject</code> 的元类就是它<strong>自己</strong></li>
<li><code>NSObject</code> 的元类的 <code>superclass</code> 就是 <code>NSObject</code></li>
</ul>
<p>对应上图中的位置关系如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/3/13/1621e9a878bc2d10?w=2500&amp;h=2624&amp;f=jpeg&amp;s=437203" alt=""></p>
<p>接着，我们用代码来验证下上文的关系：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">MyClass *myClass = [[MyClass alloc] init];</span><br><span class="line"></span><br><span class="line">Class <span class="keyword">class</span> = [myClass <span class="keyword">class</span>];</span><br><span class="line">Class metaClass = object_getClass(<span class="keyword">class</span>);</span><br><span class="line">Class metaOfMetaClass = object_getClass(metaClass);</span><br><span class="line">Class rootMetaClass = object_getClass(metaOfMetaClass);</span><br><span class="line">Class superclass = class_getSuperclass(<span class="keyword">class</span>);</span><br><span class="line">Class superOfSuperclass = class_getSuperclass(superclass);</span><br><span class="line">Class superOfMetaOfSuperclass = class_getSuperclass(object_getClass(superclass));</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"MyClass 实例对象是：%p"</span>,myClass);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"MyClass 类对象是：%p"</span>,<span class="keyword">class</span>);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"MyClass 元类对象是：%p"</span>,metaClass);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"MyClass 元类对象的元类对象是：%p"</span>,metaOfMetaClass);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"MyClass 根元类对象是：%p"</span>,rootMetaClass);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"MyClass 父类是：%@"</span>,class_getSuperclass(<span class="keyword">class</span>));</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"MyClass 父类的父类是：%@"</span>,superOfSuperclass);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"MyClass 父类的元类的父类是：%@"</span>,superOfMetaOfSuperclass);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"NSObject 元类对象是：%p"</span>,object_getClass([<span class="built_in">NSObject</span> <span class="keyword">class</span>]));</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"NSObject 父类是：%@"</span>,[[<span class="built_in">NSObject</span> <span class="keyword">class</span>] superclass]);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"NSObject 元类对象的父类是：%@"</span>,[object_getClass([<span class="built_in">NSObject</span> <span class="keyword">class</span>]) superclass]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line">MyClass 实例对象是：<span class="number">0x60c00000b8d0</span></span><br><span class="line">MyClass 类对象是：<span class="number">0x109ae3fd0</span></span><br><span class="line">MyClass 元类对象是：****<span class="number">0x109ae3fa8</span></span><br><span class="line">MyClass 元类对象的元类对象是：****<span class="number">0x10ab02e58</span>**</span><br><span class="line">MyClass 根元类对象是：<span class="number">0x10ab02e58</span></span><br><span class="line">MyClass 父类是：<span class="built_in">NSObject</span></span><br><span class="line">MyClass 父类的父类是：(null)</span><br><span class="line">MyClass 父类的元类的父类是：<span class="built_in">NSObject</span></span><br><span class="line"><span class="built_in">NSObject</span> 元类对象是：<span class="number">0x10ab02e58</span></span><br><span class="line"><span class="built_in">NSObject</span> 父类是：(null)</span><br><span class="line"><span class="built_in">NSObject</span> 元类对象的父类是：<span class="built_in">NSObject</span></span><br></pre></td></tr></table></figure>
<p>可以发现，输出结果是完全符合我们的结论的！</p>
<p>现在我们能知道各种对象之间的关系：</p>
<blockquote>
<p>实例对象通过 <code>isa</code> 指针，找到类对象 <code>Class</code>；类对象同样通过 <code>isa</code> 指针，找到元类对象；元类对象也是通过 <code>isa</code> 指针，找到根元类对象；最后，根元类对象的 <code>isa</code> 指针，指向自己。可以发现 <code>NSObject</code> 是整个消息机制的核心，绝大数对象都继承自它。</p>
</blockquote>
<h4 id="寻找流程"><a href="#寻找流程" class="headerlink" title="寻找流程"></a>寻找流程</h4><p>上文提到了，一个 Objective-C 方法会被编译成 <code>objc_msgSend</code>，这个函数有两个默认参数，<code>id</code> 类型的 <code>self</code>, <code>SEL</code> 类型的 <code>op</code>。我们先看看 <code>id</code> 的定义：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> objc_object *<span class="keyword">id</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> objc_object &#123;</span><br><span class="line">	Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p> 我们可以看到，在 <code>objc_object</code> 结构体中，只有一个指向 <code>Class</code> 类型的 <code>isa</code> 指针。</p>
<p>我们再看看 <code>Class</code> 的定义：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">	Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"><span class="meta">#if !__OBJC2__</span></span><br><span class="line">	Class _Nullable super_class  OBJC2_UNAVAILABLE;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> * _Nonnull name OBJC2_UNAVAILABLE;</span><br><span class="line">	<span class="keyword">long</span> version OBJC2_UNAVAILABLE;</span><br><span class="line">	<span class="keyword">long</span> info  OBJC2_UNAVAILABLE;</span><br><span class="line">	<span class="keyword">long</span> instance_size OBJC2_UNAVAILABLE;</span><br><span class="line">	<span class="keyword">struct</span> objc_ivar_list * _Nullable ivars  OBJC2_UNAVAILABLE;</span><br><span class="line">	<span class="keyword">struct</span> objc_method_list * _Nullable * _Nullable methodLists  		OBJC2_UNAVAILABLE;</span><br><span class="line">	<span class="keyword">struct</span> objc_cache * _Nonnull cache OBJC2_UNAVAILABLE;</span><br><span class="line">	<span class="keyword">struct</span> objc_protocol_list * _Nullable protocols  OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure>
<p>里面有很多参数，很显眼的能看到这一行：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_method_list * _Nullable * _Nullable methodLists OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure>
<p>看名字也容易理解，这个 <code>methodLists</code> 就是用来存放方法列表的。我们再看看 <code>objc_method_list</code> 这个结构体：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_method_list &#123;</span><br><span class="line">	<span class="keyword">struct</span> objc_method_list * _Nullable obsolete OBJC2_UNAVAILABLE;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> method_count OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#ifdef __LP64__</span></span><br><span class="line">	<span class="keyword">int</span> space  OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">	<span class="comment">/* variable length structure */</span></span><br><span class="line">	<span class="keyword">struct</span> objc_method method_list[<span class="number">1</span>]  OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>里面的 <code>objc_method</code> ，也就是我们熟悉的 <code>Method</code>：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_method &#123;</span><br><span class="line">	SEL _Nonnull method_name OBJC2_UNAVAILABLE;</span><br><span class="line">	<span class="keyword">char</span> * _Nullable method_types  OBJC2_UNAVAILABLE;</span><br><span class="line">	IMP _Nonnull method_imp  OBJC2_UNAVAILABLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Method</code> 里面保存了三个参数：</p>
<ul>
<li>方法的名称</li>
<li>方法的类型</li>
<li>方法的具体实现，由 <code>IMP</code> 指针指向</li>
</ul>
<p>经过层层挖掘，我们能明白实例对象调用方法的大致逻辑：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyClass *myClass = [[MyClass alloc] init];</span><br><span class="line">[myClass printLog];</span><br></pre></td></tr></table></figure>
<ul>
<li>先被编译成  <code>((void (*)(id, SEL))(void *) objc_msgSend)(myClass, @selector(printLog));</code></li>
<li>沿着入参 <code>myClass</code> 的 <code>isa</code> 指针，找到 <code>myClass</code> 的类对象（<code>Class</code>），也就是 <code>MyClass</code></li>
<li>接着在 <code>MyClass</code> 的方法列表 <code>methodLists</code> 中，找到对应的 <code>Method</code></li>
<li>最后找到 <code>Method</code> 中的 <code>IMP</code> 指针，执行具体实现</li>
</ul>
<h3 id="类对象的类方法又是怎么找到并执行的？"><a href="#类对象的类方法又是怎么找到并执行的？" class="headerlink" title="类对象的类方法又是怎么找到并执行的？"></a>类对象的类方法又是怎么找到并执行的？</h3><p>由上文，我们已经知道，<strong>实例对象是通过 <code>isa</code> 指针，找到其类对象（<code>Class</code>）中保存的方法列表中的具体实现的</strong>。</p>
<p>比如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyClass *myClass = [[MyClass alloc] init];</span><br><span class="line">[myClass printLog];</span><br></pre></td></tr></table></figure>
<p>可以理解为：<code>printLog</code> 方法就是保存在 <code>MyClass</code> 中的。</p>
<blockquote>
<p>那么如果是个<strong>类方法</strong>，又是保存在什么地方的呢？</p>
</blockquote>
<p>我们回顾下 <code>Class</code>  的定义：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_class &#123;</span><br><span class="line">	Class _Nonnull isa  OBJC_ISA_AVAILABILITY;</span><br><span class="line"><span class="meta">#if !__OBJC2__</span></span><br><span class="line">	Class _Nullable super_class  OBJC2_UNAVAILABLE;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> * _Nonnull name OBJC2_UNAVAILABLE;</span><br><span class="line">	<span class="keyword">long</span> version OBJC2_UNAVAILABLE;</span><br><span class="line">	<span class="keyword">long</span> info  OBJC2_UNAVAILABLE;</span><br><span class="line">	<span class="keyword">long</span> instance_size OBJC2_UNAVAILABLE;</span><br><span class="line">	<span class="keyword">struct</span> objc_ivar_list * _Nullable ivars  OBJC2_UNAVAILABLE;</span><br><span class="line">	<span class="keyword">struct</span> objc_method_list * _Nullable * _Nullable methodLists  		OBJC2_UNAVAILABLE;</span><br><span class="line">	<span class="keyword">struct</span> objc_cache * _Nonnull cache OBJC2_UNAVAILABLE;</span><br><span class="line">	<span class="keyword">struct</span> objc_protocol_list * _Nullable protocols  OBJC2_UNAVAILABLE;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure>
<p>可以发现到这一行：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class _Nonnull isa OBJC_ISA_AVAILABILITY;</span><br></pre></td></tr></table></figure>
<p>这里的 <code>isa</code> 同样是指向一个 <code>Class</code> 的指针。上文中，我们也知道了类对象的 <code>isa</code> 指针是指向元类对象的。那么不难得出：</p>
<blockquote>
<p>类对象的类方法，是保存在元类对象中的！</p>
</blockquote>
<p>类对象和元类对象都是  <code>Class</code> 类型，仅仅服务的对象不同罢了。找到了元类对象，自然就找到了元类对象中的 <code>methodLists</code>，接下来就和实例对象的方法寻找调用一样的流程了。</p>
<h3 id="如何提高方法查找的效率？"><a href="#如何提高方法查找的效率？" class="headerlink" title="如何提高方法查找的效率？"></a>如何提高方法查找的效率？</h3><p>上文中，我们大概知道，方法是通过 <code>isa</code> 指针，查找 <code>Class</code> 中的 <code>methodLists</code> 的。如果子类没实现对应的方法实现，还会沿着父类去查找。整个工程，可能有<strong>成万上亿</strong>个方法，是如何解决性能问题的呢？</p>
<p>例如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; ++i) &#123;</span><br><span class="line">    MyClass *myObject = myObjects[i];</span><br><span class="line">    [myObject methodA];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种高频次的调用 <code>methodA</code>，如果每调用一次都需要遍历，性能是非常差的。所以引入了 Class Cache 机制：</p>
<blockquote>
<p> Class Cache 认为，当一个方法被调用，那么它之后被调用的可能性就越大。</p>
</blockquote>
<p>查找方法时，会先从缓存中查找，找到直接返回 ；找不到，再去 <code>Class</code> 的方法列表中找。</p>
<p>在上文中 <code>Class</code> 的定义中，我们可以发现  <code>cache</code>：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> objc_cache * _Nonnull cache OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure>
<p>说明了<strong>缓存是存在类中的，每个类都有一份方法缓存，而不是每个类的 <code>object</code> 都保存了一份。</strong></p>
<h3 id="关于父类（superclass）"><a href="#关于父类（superclass）" class="headerlink" title="关于父类（superclass）"></a>关于父类（superclass）</h3><p>在 Objective-C 中，子类调用一个方法，如果没有子类没有实现，父类实现了，会去调用父类的实现。上文中，找到 <code>methodLists</code> 后，寻找 <code>Method</code> 的大致过程如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/3/15/162279fe6e420501?w=858&amp;h=758&amp;f=png&amp;s=50302" alt=""></p>
<blockquote>
<p>ps: 其实这里的寻找过程远没有这么简单，可能会遍历很多遍，因为我们可能会在运行时动态的添加方法（比如 <code>category</code>）。<strong>遍历的过程中同样不时的去查询缓存表。</strong></p>
</blockquote>
<h2 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h2><p>如果方法列表（<code>methodLists</code>）没找到对应的 <code>selector</code> 呢？</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ViewController.m 中 （未实现 myTestPrint 方法）</span></span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(myTestPrint:) withObject:<span class="string">@"，你好 ！"</span>];</span><br></pre></td></tr></table></figure>
<p>系统会提供<strong>三次</strong>补救的机会。</p>
<h3 id="第一次"><a href="#第一次" class="headerlink" title="第一次"></a>第一次</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;&#125; (实例方法)</span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveClassMethod:(SEL)sel &#123;&#125;  (类方法)</span><br></pre></td></tr></table></figure>
<p>这两个方法，一个针对实例方法；一个针对类方法。返回值都是 <code>Bool</code>。</p>
<p>使用示例：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ViewController.m 中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> myMethod(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd,<span class="built_in">NSString</span> *nub) &#123;</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"ifelseboyxx%@"</span>,nub);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line"><span class="meta">#pragma clang diagnostic push</span></span><br><span class="line"><span class="meta">#pragma clang diagnostic ignored <span class="meta-string">"-Wundeclared-selector"</span></span></span><br><span class="line">    <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(myTestPrint:)) &#123;</span><br><span class="line"><span class="meta">#pragma clang diagnostic pop</span></span><br><span class="line">        class_addMethod([<span class="keyword">self</span> <span class="keyword">class</span>],sel,(IMP)myMethod,<span class="string">"v@:@"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们只需要在 <code>resolveInstanceMethod:</code> 方法中，利用 <code>class_addMethod</code> 方法，将未实现的 <code>myTestPrint:</code> 绑定到 <code>myMethod</code> 上就能完成转发，最后返回 <code>YES</code>。</p>
<h3 id="第二次"><a href="#第二次" class="headerlink" title="第二次"></a>第二次</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法要求返回一个 <code>id</code>。使用场景一般是将 A 类的某个方法，转发到 B 类的实现中去。</p>
<p>使用示例：</p>
<p>想转发到 <code>Person</code> 类中的 <code>-myTestPrint:</code> 方法中：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line">- (<span class="keyword">void</span>)myTestPrint:(<span class="built_in">NSString</span> *)str &#123;</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"ifelseboyxx%@"</span>,str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// ViewController.m 中</span><br><span class="line"></span><br><span class="line">- (id)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored &quot;-Wundeclared-selector&quot;</span><br><span class="line">    if (aSelector == @selector(myTestPrint:)) &#123;</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">        return [Person new];</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return [super forwardingTargetForSelector:aSelector];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第三次"><a href="#第三次" class="headerlink" title="第三次"></a>第三次</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector &#123;&#125;</span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>第一个要求返回一个方法签名，第二个方法转发具体的实现。二者相互依赖，只有返回了正确的方法签名，才会执行第二个方法。</p>
<p>这次的转发作用和第二次的比较类似，都是将 A 类的某个方法，转发到 B 类的实现中去。不同的是，第三次的转发相对于第二次更加<strong>灵活</strong>，<code>forwardingTargetForSelector:</code> 只能固定的转发到一个对象；<code>forwardInvocation:</code>  <strong>可以让我们转发到多个对象中去</strong>。</p>
<p>使用实例：</p>
<p>想转发到 <code>Person</code> 类以及 <code>Animal</code> 类中的 <code>-myTestPrint:</code> 方法中：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line">- (<span class="keyword">void</span>)myTestPrint:(<span class="built_in">NSString</span> *)str &#123;</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"ifelseboyxx%@"</span>,str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Animal</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Animal</span></span></span><br><span class="line">- (<span class="keyword">void</span>)myTestPrint:(<span class="built_in">NSString</span> *)str &#123;</span><br><span class="line">	<span class="built_in">NSLog</span>(<span class="string">@"tiger%@"</span>,str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ViewController.m 中</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">	<span class="meta">#pragma clang diagnostic push</span></span><br><span class="line">	<span class="meta">#pragma clang diagnostic ignored <span class="meta-string">"-Wundeclared-selector"</span></span></span><br><span class="line">	<span class="keyword">if</span> (aSelector == <span class="keyword">@selector</span>(myTestPrint:)) &#123;</span><br><span class="line">	<span class="meta">#pragma clang diagnostic pop</span></span><br><span class="line">	<span class="keyword">return</span> [<span class="built_in">NSMethodSignature</span>  signatureWithObjCTypes:<span class="string">"v@:@"</span>];</span><br><span class="line">&#125;</span><br><span class="line">	<span class="keyword">return</span> [<span class="keyword">super</span> methodSignatureForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation &#123;</span><br><span class="line">	Person *person = [Person new];</span><br><span class="line">	Animal *animal = [Animal new];</span><br><span class="line">	<span class="keyword">if</span> ([person respondsToSelector:anInvocation.selector]) &#123;</span><br><span class="line">		[anInvocation invokeWithTarget:person];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> ([animal respondsToSelector:anInvocation.selector]) &#123;</span><br><span class="line">		[anInvocation invokeWithTarget:animal];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>⚠️ 如果到了第三次机会，还没找到对应的实现，就会 crash：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unrecognized selector sent to instance <span class="number">0x7f9f817072b0</span></span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到这里，我们大概能了解消息发送与转发的过程了。整理了下大致的流程，有问题欢迎大家积极提出来：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/3/15/162279c7ab3eedfc?w=1117&amp;h=1014&amp;f=png&amp;s=119757" alt=""></p>
</div><iframe src="/donate/?AliPayQR=/img/AliPay.png&amp;WeChatQR=/img/WechatPay.png&amp;GitHub=null&amp;BTCQR=null&amp;BTCKEY=null&amp;PayPal=null" style="overflow-x:hidden; overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;" frameborder="0" scrolling="no"></iframe><div class="tags"></div><div class="post-nav"><a class="pre" href="/2018/12/27/2018_questioning/">2018 年度总结</a><a class="next" href="/2018/04/24/log_analysis/">iOS crash 日志堆栈解析</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'http://yoursite.com/2018/08/19/message_forward/';
    this.page.identifier = '2018/08/19/message_forward/';
    this.page.title = 'iOS 消息发送与转发详解';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//leeeisok.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//leeeisok.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://leeeisok.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });
</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Swift/">Swift</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/总结/">总结</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/12/27/2018_questioning/">2018 年度总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/19/message_forward/">iOS 消息发送与转发详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/24/log_analysis/">iOS crash 日志堆栈解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/06/self_release/">聊聊 iOS 中的自释放</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/13/swift_tips/">Swift 小知识点</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/06/responder_chain/">基于 ResponderChain 的对象交互方式</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/06/list_optimize/">iOS 中关于列表滚动流畅方案的一些探讨</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//leeeisok.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">秃头披风侠.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>