<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>iOS crash 日志堆栈解析 | 秃头披风侠</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">iOS crash 日志堆栈解析</h1><a id="logo" href="/.">秃头披风侠</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">iOS crash 日志堆栈解析</h1><div class="post-meta">Apr 24, 2018<span> | </span><span class="category"><a href="/categories/iOS/">iOS</a></span></div><a class="disqus-comment-count" data-disqus-identifier="2018/04/24/log_analysis/" href="/2018/04/24/log_analysis/#disqus_thread"></a><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#symbolicatecrash"><span class="toc-text">symbolicatecrash</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#dSYM-文件"><span class="toc-text">.dSYM 文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#symbols-又是什么呢？"><span class="toc-text">symbols 又是什么呢？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#找到-symbolicatecrash"><span class="toc-text">找到 symbolicatecrash</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#拿到-crash-日志文件"><span class="toc-text">拿到 crash 日志文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#拿到-app-文件"><span class="toc-text">拿到 .app 文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#符号解析"><span class="toc-text">符号解析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#利用-dSYM"><span class="toc-text">利用 dSYM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#利用-app"><span class="toc-text">利用 app</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用命令行工具-atos"><span class="toc-text">使用命令行工具 atos</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是-UUID"><span class="toc-text">什么是 UUID ?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取-UUID"><span class="toc-text">获取 UUID</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#crash-UUID"><span class="toc-text">.crash UUID</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dSYM-UUID"><span class="toc-text">.dSYM UUID</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#app-UUID"><span class="toc-text">.app UUID</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#atos-解析"><span class="toc-text">atos 解析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#工具"><span class="toc-text">工具</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#系统库的符号化解析"><span class="toc-text">系统库的符号化解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-text">参考</span></a></li></ol></div></div><div class="post-content"><p>日常开放中，我们难免遇到一些 crash。大部分情况下，Xcode 可以帮助我们找到问题所在，但也有些情况，Xcode 给我们反馈的是一些看不懂的地址，大大增加了我们分析问题的难度。</p>
<p>下面，就来介绍几种能让看不懂的地址，变得看的懂的方式。</p>
<h2 id="symbolicatecrash"><a href="#symbolicatecrash" class="headerlink" title="symbolicatecrash"></a>symbolicatecrash</h2><h3 id="dSYM-文件"><a href="#dSYM-文件" class="headerlink" title=".dSYM 文件"></a>.dSYM 文件</h3><p>dSYM 是保存十六进制函数地址映射信息的中转文件，我们调试的 symbols 都会包含在这个文件中。每次编译项目的时候都会生成一个新的 dSYM 文件，<strong>我们应该保存每个正式发布版本的 dSYM 文件，以备我们更好的调试问题</strong>。一般是在我们 Archives 时保存对应的版本文件的，里面也有对应的 <code>.dSYM</code> 和 <code>.app</code> 文件。路径为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/Library/Developer/Xcode/Archives</span><br></pre></td></tr></table></figure>
<p><strong><code>.dSYM</code> 文件默认在 debug 模式下是不生成的</strong>，我们去 Build Settings -&gt; Debug Information Format 下，将 <code>DWARF</code> 修改为 <code>DWARF with dSYM File</code>，再重新编译下就能生成 <code>.dSYM</code> 文件了，直接去项目工程的 <code>Products</code> 目录下找就行。</p>
<h4 id="symbols-又是什么呢？"><a href="#symbols-又是什么呢？" class="headerlink" title="symbols 又是什么呢？"></a>symbols 又是什么呢？</h4><p>引用 《程序员的自我修养》中的解释：</p>
<blockquote>
<p>在链接中，我们将函数和变量统称为符号（Symbol），函数名或变量名就是符号名（Symbol Name）。我们可以将符号看作是链接中的粘合剂，整个链接过程正是基于符号才能够正确完成。</p>
</blockquote>
<p>所以，所谓的 symbols 就是<strong>函数名或变量名</strong>。</p>
<h3 id="找到-symbolicatecrash"><a href="#找到-symbolicatecrash" class="headerlink" title="找到 symbolicatecrash"></a>找到 symbolicatecrash</h3><p><code>symbolicatecrash</code> 是 Xcode 自带的 crash 日志分析工具，我们需要先找到它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /Applications/Xcode.app -name symbolicatecrash -type f</span><br></pre></td></tr></table></figure>
<p>执行完后会返回几个路径，我的是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/Library/PrivateFrameworks/DVTFoundation.framework/symbolicatecrash</span><br></pre></td></tr></table></figure></p>
<p>我们到这个路径下把 <code>symbolicatecrash</code> 拷贝出来，放到一个文件夹下。</p>
<h3 id="拿到-crash-日志文件"><a href="#拿到-crash-日志文件" class="headerlink" title="拿到 crash 日志文件"></a>拿到 crash 日志文件</h3><p>我们可以随便写段强制 crash 的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">	NSArray *arr = @[];</span><br><span class="line">	arr[100];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着用<strong>真机</strong>打个包。打好包之后，<strong>不要用 Xcode build</strong>，<strong>直接用打好的包运行我们能导致 crash 的代码</strong>，这样就生成好 <code>.crash</code> 日志文件了。</p>
<p>之后，我们去 Xcode -&gt; Window -&gt; Devices and Simulators 或者快捷键 <strong>Command + Shift + 2</strong></p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/24/162f76db7dbdc499?w=2084&amp;h=464&amp;f=png&amp;s=96156" alt=""></p>
<p>找到对应时间点的 .crash 文件，右击 Export Log。</p>
<h3 id="拿到-app-文件"><a href="#拿到-app-文件" class="headerlink" title="拿到 .app 文件"></a>拿到 .app 文件</h3><p><code>.app</code> 文件可以使用真机编译下，去 项目 <code>Products</code>  目录下获取，也可以去 Archives 目录下获取。</p>
<h3 id="符号解析"><a href="#符号解析" class="headerlink" title="符号解析"></a>符号解析</h3><h4 id="利用-dSYM"><a href="#利用-dSYM" class="headerlink" title="利用 dSYM"></a>利用 dSYM</h4><p>将 <code>.dSYM</code> 、<code>.crash</code> 及 <code>symbolicatecrash</code> 放到同一个文件下，执行命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./symbolicatecrash .crash文件路径 .dSYM文件路径 &gt; 名字.crash</span><br></pre></td></tr></table></figure>
<h4 id="利用-app"><a href="#利用-app" class="headerlink" title="利用 app"></a>利用 app</h4><p>将 <code>.app</code> 、<code>.crash</code> 及 <code>symbolicatecrash</code> 放到同一个文件下，执行命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./symbolicatecrash .crash文件路径 .app/appName 路径 &gt; 名字.crash</span><br></pre></td></tr></table></figure>
<p>可能会报错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Error: &quot;DEVELOPER_DIR&quot; is not defined at ./symbolicatecrash line 69.</span><br></pre></td></tr></table></figure>
<p>执行下命令就行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export DEVELOPER_DIR=/Applications/Xcode.app/Contents/Developer</span><br></pre></td></tr></table></figure>
<p>然后再重新生成下新的 <code>.crash</code> 文件就行。</p>
<p>我们可以对比下没有符号化和符号化的文件，下面是我自己测试的例子，<code>iPhone5 iOS 10.2</code>， 可能会有所不同：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Last Exception Backtrace:</span><br><span class="line">0   CoreFoundation                	0x1df60df2 __exceptionPreprocess + 126</span><br><span class="line">1   libobjc.A.dylib               	0x1d1c3072 objc_exception_throw + 33</span><br><span class="line">2   CoreFoundation                	0x1dee62f2 -[__NSArray0 objectAtIndex:] + 105</span><br><span class="line">3   DreamDemo                     	0x0008088e 0x7c000 + 18574</span><br><span class="line">4   UIKit                         	0x2319eb44 forwardTouchMethod + 289</span><br><span class="line">5   UIKit                         	0x2319ea10 -[UIResponder touchesBegan:withEvent:] + 29</span><br><span class="line">6   UIKit                         	0x23041c58 -[UIWindow _sendTouchesForEvent:] + 1599</span><br><span class="line">7   UIKit                         	0x2303ca62 -[UIWindow sendEvent:] + 2657</span><br><span class="line">8   UIKit                         	0x2300d870 -[UIApplication sendEvent:] + 315</span><br><span class="line">9   UIKit                         	0x237a8998 __dispatchPreprocessedEventFromEventQueue + 2615</span><br><span class="line">10  UIKit                         	0x237a25de __handleEventQueue + 829</span><br><span class="line">11  CoreFoundation                	0x1df1c716 __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 7</span><br><span class="line">12  CoreFoundation                	0x1df1c220 __CFRunLoopDoSources0 + 433</span><br><span class="line">13  CoreFoundation                	0x1df1a4f6 __CFRunLoopRun + 757</span><br><span class="line">14  CoreFoundation                	0x1de6952e CFRunLoopRunSpecific + 481</span><br><span class="line">15  CoreFoundation                	0x1de6933c CFRunLoopRunInMode + 99</span><br><span class="line">16  GraphicsServices              	0x1f640bf8 GSEventRunModal + 151</span><br><span class="line">17  UIKit                         	0x230789a2 -[UIApplication _run] + 569</span><br><span class="line">18  UIKit                         	0x230730cc UIApplicationMain + 145</span><br><span class="line">19  DreamDemo                     	0x000834cc 0x7c000 + 29900</span><br><span class="line">20  libdyld.dylib                 	0x1d633506 _dyld_process_info_notify_release + 23</span><br></pre></td></tr></table></figure>
<p>问题也能看出来，但是因为第三行（DreamDemo）并没有符号化，<strong>导致我们并不确定具体调用位置。</strong></p>
<p>再来看看符号化之后的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Last Exception Backtrace:</span><br><span class="line">0   CoreFoundation                	0x1df60df2 __exceptionPreprocess + 126</span><br><span class="line">1   libobjc.A.dylib               	0x1d1c3072 objc_exception_throw + 33</span><br><span class="line">2   CoreFoundation                	0x1dee62f2 -[__NSArray0 objectAtIndex:] + 105</span><br><span class="line">3   DreamDemo                     	0x0008088e -[ViewController touchesBegan:withEvent:] + 18574 (ViewController.m:84)</span><br><span class="line">4   UIKit                         	0x2319eb44 forwardTouchMethod + 289</span><br><span class="line">5   UIKit                         	0x2319ea10 -[UIResponder touchesBegan:withEvent:] + 29</span><br><span class="line">6   UIKit                         	0x23041c58 -[UIWindow _sendTouchesForEvent:] + 1599</span><br><span class="line">7   UIKit                         	0x2303ca62 -[UIWindow sendEvent:] + 2657</span><br><span class="line">8   UIKit                         	0x2300d870 -[UIApplication sendEvent:] + 315</span><br><span class="line">9   UIKit                         	0x237a8998 __dispatchPreprocessedEventFromEventQueue + 2615</span><br><span class="line">10  UIKit                         	0x237a25de __handleEventQueue + 829</span><br><span class="line">11  CoreFoundation                	0x1df1c716 __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__ + 7</span><br><span class="line">12  CoreFoundation                	0x1df1c220 __CFRunLoopDoSources0 + 433</span><br><span class="line">13  CoreFoundation                	0x1df1a4f6 __CFRunLoopRun + 757</span><br><span class="line">14  CoreFoundation                	0x1de6952e CFRunLoopRunSpecific + 481</span><br><span class="line">15  CoreFoundation                	0x1de6933c CFRunLoopRunInMode + 99</span><br><span class="line">16  GraphicsServices              	0x1f640bf8 GSEventRunModal + 151</span><br><span class="line">17  UIKit                         	0x230789a2 -[UIApplication _run] + 569</span><br><span class="line">18  UIKit                         	0x230730cc UIApplicationMain + 145</span><br><span class="line">19  DreamDemo                     	0x000834cc main + 29900 (main.m:15)</span><br><span class="line">20  libdyld.dylib                 	0x1d633506 _dyld_process_info_notify_release + 23</span><br></pre></td></tr></table></figure>
<p>可以发现，第三行被解析出来了，这样我们就能很清晰的知道具体的页面了。</p>
<h2 id="使用命令行工具-atos"><a href="#使用命令行工具-atos" class="headerlink" title="使用命令行工具 atos"></a>使用命令行工具 atos</h2><p>symbolicatecrash 可以帮助我们很好的分析 crash 日志，但是有它的局限性 — 不够灵活。我们需要 <code>symbolicatecrash</code>、<code>.crash</code> 及 <code>.dSYM</code>  三个文件才能解析。</p>
<p>相对于 symbolicatecrash， <code>atos</code> 命令更加灵活，特别是你需要对不同渠道的 crash 文件，写一个自动化的分析脚本的时候，这个方法就极其有用。</p>
<p>但是这种方式也有个不方便的地方：一个线上的 App，用户使用的版本存在差异，而每个版本所对应的 <code>.dSYM</code> 都是不同的。<strong>必须确保 <code>.crash</code> 和 <code>.dSYM</code> 文件是匹配的</strong>，才能正确符号化，<strong>匹配的条件就是它们的 UUID 一致</strong>。<br>在这之前，先介绍下 UUID：</p>
<h3 id="什么是-UUID"><a href="#什么是-UUID" class="headerlink" title="什么是 UUID ?"></a>什么是 UUID ?</h3><p>UUID 是由一组 32 位数的十六进制数字所构成。每一个可执行程序都有一个 build UUID 唯一标识。<code>.crash</code>日志包含发生 crash 的这个应用的 build UUID 以及 crash 发生时，应用加载的所有库文件的 build UUID。</p>
<h3 id="获取-UUID"><a href="#获取-UUID" class="headerlink" title="获取 UUID"></a>获取 UUID</h3><h4 id="crash-UUID"><a href="#crash-UUID" class="headerlink" title=".crash UUID"></a>.crash UUID</h4><p>执行命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep --after-context=2 &quot;Binary Images:&quot; *crash</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">T.crash:Binary Images:</span><br><span class="line">T.crash-0x7c000 - 0x87fff DreamDemo armv7  &lt;d009f8671129397a8aab9cb2b8e506ff&gt; /var/containers/Bundle/Application/DEEBE571-D512-4E8F-B712-ED4D19CE64F9/DreamDemo.app/DreamDemo</span><br><span class="line">T.crash-0xa9000 - 0xd4fff dyld armv7s  &lt;cd60ff3403063c0aa8e54dff11e42527&gt; /usr/lib/dyld</span><br></pre></td></tr></table></figure>
<p>看到上面的输出 <code>d009f8671129397a8aab9cb2b8e506ff</code> 就是 <code>DreamDemo</code> 项目的 UUID。</p>
<h4 id="dSYM-UUID"><a href="#dSYM-UUID" class="headerlink" title=".dSYM UUID"></a>.dSYM UUID</h4><p>执行命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dwarfdump --uuid DreamDemo.app.dSYM</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UUID: D009F867-1129-397A-8AAB-9CB2B8E506FF (armv7) DreamDemo.app.dSYM/Contents/Resources/DWARF/DreamDemo</span><br></pre></td></tr></table></figure>
<h4 id="app-UUID"><a href="#app-UUID" class="headerlink" title=".app UUID"></a>.app UUID</h4><p>执行命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dwarfdump --uuid DreamDemo.app/DreamDemo</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UUID: D009F867-1129-397A-8AAB-9CB2B8E506FF (armv7) DreamDemo.app/DreamDemo</span><br></pre></td></tr></table></figure>
<p><strong>可以发现这两个文件的 UUID 是相同的，也就是匹配的，只有满足这种条件，才能正确的解析！</strong></p>
<h4 id="atos-解析"><a href="#atos-解析" class="headerlink" title="atos 解析"></a>atos 解析</h4><p>我们现回顾下未解析前的堆栈：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2   CoreFoundation                	0x1dee62f2 -[__NSArray0 objectAtIndex:] + 105</span><br><span class="line">3   DreamDemo                     	0x0008088e 0x7c000 + 18574</span><br><span class="line">4   UIKit                         	0x2319eb44 forwardTouchMethod + 289</span><br><span class="line">5   UIKit                         	0x2319ea10 -[UIResponder touchesBegan:withEvent:] + 29</span><br></pre></td></tr></table></figure>
<p>执行命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun atos -o DreamDemo.app.dSYM/Contents/Resources/DWARF/DreamDemo -arch armv7 -l 0x7c000</span><br></pre></td></tr></table></figure>
<p>接着输入 <code>0x0008088e</code> 地址，终端输出如下：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/24/162f76db7dc97649?w=1300&amp;h=842&amp;f=png&amp;s=102288" alt=""></p>
<p>可以发现，正确的解析出来了！</p>
<p><strong>除了搭配 <code>.dSYM</code> 文件，我们也可以使用 <code>.app</code> 文件来解析：</strong></p>
<p>执行命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcrun atos -o DreamDemo.app/DreamDemo -arch armv7 -l 0x7c000</span><br></pre></td></tr></table></figure>
<p>同样输入 <code>0x0008088e</code> 地址，效果是一样的。</p>
<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><p>直接操作 <code>atos</code> 命令毕竟是有点不方便，GitHub 上有个工具，可以辅助我们解析 <a href="https://github.com/answer-huang/dSYMTools" target="_blank" rel="noopener">dSYMTools</a> ，这是个 Mac 客户端，界面长这样：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/25/162fa45b842e153d?w=1036&amp;h=1076&amp;f=png&amp;s=116876" alt=""></p>
<p>使用起来也很方便，我们只需要把对应的 <code>dSYM</code> 文件拖进去，它会自动识别 UUID。我们对应的输入参数地址就行：</p>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/25/162fa45b8447792d?w=1036&amp;h=1076&amp;f=png&amp;s=136554" alt=""></p>
<h2 id="系统库的符号化解析"><a href="#系统库的符号化解析" class="headerlink" title="系统库的符号化解析"></a>系统库的符号化解析</h2><p>细心的人可以发现，我们上面的解析都是针对 <code>DreamDemo</code> ，这个自己的项目的。其实很多系统方法的堆栈之所以能解析出来，是因为已经有了系统库的符号化文件，存放目录如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/用户/用户名称xxx/资源库/Developer/Xcode/iOS DeviceSupport</span><br></pre></td></tr></table></figure>
<p><img src="https://user-gold-cdn.xitu.io/2018/4/25/162fa45b8433c71f?w=940&amp;h=882&amp;f=png&amp;s=90982" alt=""></p>
<p>这些库的版本都是和 <code>.crash</code> 文件中是对应的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OS Version:          iPhone OS 10.2 (14C5077b)</span><br></pre></td></tr></table></figure>
<p>一旦我把这个 <code>10.2 (14C5077b)</code> 系统的符号化库删掉，<code>.crash</code> 文件就会变成这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Last Exception Backtrace:</span><br><span class="line">0   CoreFoundation                	0x1df60df2 0x1de5f000 + 1056242</span><br><span class="line">1   libobjc.A.dylib               	0x1d1c3072 0x1d1bc000 + 28786</span><br><span class="line">2   CoreFoundation                	0x1dee62f2 0x1de5f000 + 553714</span><br><span class="line">3   DreamDemo                     	0x000bc66e -[ViewController touchesBegan:withEvent:] + 18030 (ViewController.m:78)</span><br><span class="line">4   UIKit                         	0x2319eb44 0x22ffe000 + 1706820</span><br><span class="line">5   UIKit                         	0x2319ea10 0x22ffe000 + 1706512</span><br><span class="line">6   UIKit                         	0x23041c58 0x22ffe000 + 277592</span><br><span class="line">7   UIKit                         	0x2303ca62 0x22ffe000 + 256610</span><br><span class="line">8   UIKit                         	0x2300d870 0x22ffe000 + 63600</span><br><span class="line">9   UIKit                         	0x237a8998 0x22ffe000 + 8038808</span><br><span class="line">10  UIKit                         	0x237a25de 0x22ffe000 + 8013278</span><br><span class="line">11  CoreFoundation                	0x1df1c716 0x1de5f000 + 775958</span><br><span class="line">12  CoreFoundation                	0x1df1c220 0x1de5f000 + 774688</span><br><span class="line">13  CoreFoundation                	0x1df1a4f6 0x1de5f000 + 767222</span><br><span class="line">14  CoreFoundation                	0x1de6952e 0x1de5f000 + 42286</span><br><span class="line">15  CoreFoundation                	0x1de6933c 0x1de5f000 + 41788</span><br><span class="line">16  GraphicsServices              	0x1f640bf8 0x1f637000 + 39928</span><br><span class="line">17  UIKit                         	0x230789a2 0x22ffe000 + 502178</span><br><span class="line">18  UIKit                         	0x230730cc 0x22ffe000 + 479436</span><br><span class="line">19  DreamDemo                     	0x000bf332 main + 29490 (main.m:15)</span><br><span class="line">20  libdyld.dylib                 	0x1d633506 0x1d630000 + 13574</span><br></pre></td></tr></table></figure>
<p>可以明显的发现，系统库的堆栈变成了一堆地址。</p>
<p>新版本，每当我们手机连上 Xcode 时，都会把当前版本的系统符号库自动导入到 <code>/用户/用户名称xxx/资源库/Developer/Xcode/iOS DeviceSupport</code> 目录下。但是 iOS 版本那么多，之前旧的系统符号库该怎么获取呢？有人已经整理好了 <a href="https://github.com/Zuikyo/iOS-System-Symbols" target="_blank" rel="noopener">iOS-System-Symbols</a>，我们只需要根据 <code>.crash</code> 文件的版本信息，下载对应的系统符号化文件到目录下即可。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>利用 symbolicatecrash 解析，可以将整个 <code>.crash</code> 日志堆栈解析，但是由于依赖 <code>symbolicatecrash</code>、<code>.crash</code> 以及 <code>.dSYM</code> 三个文件，或者 <code>.app</code> 、<code>.crash</code> 及 <code>symbolicatecrash</code> 三个文件，导致不太灵活。</li>
<li>利用 <code>atos</code> 命令只需要 <code>.crash</code>和 <code>.dSYM</code> ，或者 <code>.crash</code>和 <code>.app</code>，知道对应的堆栈地址，就能解析，方便自动化脚本分析，但是 crash 堆栈可能需要自己实现收集。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://wufawei.com/2014/03/symbolicating-ios-crash-logs/" target="_blank" rel="noopener">http://wufawei.com/2014/03/symbolicating-ios-crash-logs/</a></p>
</div><iframe src="/donate/?AliPayQR=/img/AliPay.png&amp;WeChatQR=/img/WechatPay.png&amp;GitHub=null&amp;BTCQR=null&amp;BTCKEY=null&amp;PayPal=null" style="overflow-x:hidden; overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;" frameborder="0" scrolling="no"></iframe><div class="tags"></div><div class="post-nav"><a class="pre" href="/2018/08/19/message_forward/">iOS 消息发送与转发详解</a><a class="next" href="/2018/03/06/self_release/">聊聊 iOS 中的自释放</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'http://yoursite.com/2018/04/24/log_analysis/';
    this.page.identifier = '2018/04/24/log_analysis/';
    this.page.title = 'iOS crash 日志堆栈解析';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//leeeisok.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//leeeisok.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://leeeisok.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });
</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Swift/">Swift</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/其他/">其他</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/思考/">思考</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/总结/">总结</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/05/23/competition_analysis/">竞品分析实战</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/01/trainingday/">影片《训练日》-- 观后感</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/12/27/2018_questioning/">2018 年度总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/19/message_forward/">iOS 消息发送与转发详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/24/log_analysis/">iOS crash 日志堆栈解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/06/self_release/">聊聊 iOS 中的自释放</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/13/swift_tips/">Swift 小知识点</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/06/responder_chain/">基于 ResponderChain 的对象交互方式</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/06/list_optimize/">iOS 中关于列表滚动流畅方案的一些探讨</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//leeeisok.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">秃头披风侠.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>