<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Swift 小知识点 | 秃头披风侠</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Swift 小知识点</h1><a id="logo" href="/.">秃头披风侠</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Swift 小知识点</h1><div class="post-meta">Feb 13, 2018<span> | </span><span class="category"><a href="/categories/Swift/">Swift</a></span></div><a class="disqus-comment-count" data-disqus-identifier="2018/02/13/swift_tips/" href="/2018/02/13/swift_tips/#disqus_thread"></a><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Associated-Object"><span class="toc-text">Associated Object</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Delegate-声明为-weak"><span class="toc-text">Delegate 声明为 weak</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#可选协议和协议扩展"><span class="toc-text">可选协议和协议扩展</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#单例"><span class="toc-text">单例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#输出格式化"><span class="toc-text">输出格式化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1.1.6"><span class="toc-text"> Selector </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#将-protocol-的方法声明为-mutating"><span class="toc-text">将 protocol 的方法声明为 mutating</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数组遍历-enumerate"><span class="toc-text">数组遍历 enumerate</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#输入输出参数-inout"><span class="toc-text">输入输出参数 inout</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Default-参数"><span class="toc-text">Default 参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#延迟加载-lazy"><span class="toc-text">延迟加载 lazy</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#编译标记"><span class="toc-text">编译标记</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#换行符"><span class="toc-text">换行符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字符串切割-split"><span class="toc-text">字符串切割 split</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#KVC"><span class="toc-text">KVC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1.2.6"><span class="toc-text"> Swift 中值类型和引用类型注意点 </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#KVO"><span class="toc-text">KVO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Swift-UIButton-状态的叠加"><span class="toc-text">Swift UIButton 状态的叠加</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Swift-中的-“-synchronized”"><span class="toc-text">Swift 中的 “@synchronized”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自定义日志输出"><span class="toc-text">自定义日志输出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Swift-中的-“readonly”"><span class="toc-text">Swift 中的 “readonly”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#作用域：do-语句块"><span class="toc-text">作用域：do 语句块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#倒序-reversed"><span class="toc-text">倒序 reversed()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#标签语句：指定跳出某个条件语句"><span class="toc-text">标签语句：指定跳出某个条件语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#优雅的定义通知名称"><span class="toc-text">优雅的定义通知名称</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#weakSelf-和-strongSelf"><span class="toc-text">weakSelf 和 strongSelf</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#几种遍历方式"><span class="toc-text">几种遍历方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#访问级别"><span class="toc-text">访问级别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#for-in-和-forEach-的区别"><span class="toc-text">for in 和 forEach 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1.4.0"><span class="toc-text"> 取消 asyncAfter 中延迟的事件 </span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#善用-exception-来避免多个协议"><span class="toc-text">善用 exception 来避免多个协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#多使用类型推断"><span class="toc-text">多使用类型推断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用-autoclosure-使代码更加优雅"><span class="toc-text">使用 @autoclosure 使代码更加优雅</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#利用-Set-去重并保持顺序"><span class="toc-text">利用 Set 去重并保持顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#利用-contains-判断元素是否满足条件"><span class="toc-text">利用 contains 判断元素是否满足条件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#map、flatMap和compactMap-区别"><span class="toc-text">map、flatMap和compactMap 区别</span></a></li></ol></div></div><div class="post-content"><p>以下内容均是笔者学习过程中<strong>收集</strong>的知识点，基于 <code>Swift 4.0+</code> 顺序比较跳跃，初衷是为了方便查阅，顺便加深记忆。如果有什么问题或者有好的 Swift 方面的语法糖或者知识点也可以提出来，欢迎大家关注～</p>
<h2 id="Associated-Object"><a href="#Associated-Object" class="headerlink" title="Associated Object"></a>Associated Object</h2><p>Objective-C 的 runtime 里的 Associated Object 允许我们在使用 Category 扩展现有的类的功能的时候，直接添加实例变量。在 Swift 中 extension 不能添加<strong>存储属性</strong>，我们可以利用 Associated Object 来实现，比如下面的 <code>title</code> 「实际上」是一个存储属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyClass.swift</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MyClassExtension.swift</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> key: <span class="type">Void</span>?</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> title: <span class="type">String</span>? &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, &amp;key) <span class="keyword">as</span>? <span class="type">String</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            objc_setAssociatedObject(<span class="keyword">self</span>, &amp;key, newValue, .<span class="type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printTitle</span><span class="params">(<span class="number">_</span> input: MyClass)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> title = input.title &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Title: \(title)"</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"没有设置"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = <span class="type">MyClass</span>()</span><br><span class="line">printTitle(a)</span><br><span class="line">a.title = <span class="string">"Swifter.tips"</span></span><br><span class="line">printTitle(a)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 没有设置</span></span><br><span class="line"><span class="comment">// Title: Swifter.tips”</span></span><br></pre></td></tr></table></figure>
<h2 id="Delegate-声明为-weak"><a href="#Delegate-声明为-weak" class="headerlink" title="Delegate 声明为 weak"></a>Delegate 声明为 weak</h2><p>Swift 中 Delegate 需要被声明成 <code>weak</code>，来避免访问到已被回收的内存而导致崩溃，如果我们像下面这样，是编译不过的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">MyClassDelegate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">weak</span> <span class="keyword">var</span> delegate: <span class="type">MyClassDelegate</span>?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>, <span class="title">MyClassDelegate</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">var</span> someInstance: <span class="type">MyClass</span>!</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        someInstance = <span class="type">MyClass</span>()</span><br><span class="line">        someInstance.delegate = <span class="keyword">self</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">method</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Do something"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译失败</span></span><br><span class="line"><span class="comment">// 'weak' may only be applied to class and class-bound protocol types, not 'MyClassDelegate'</span></span><br></pre></td></tr></table></figure>
<p>这是因为 Swift 的 protocol 是可以被除了 class 以外的其他类型遵守的，而对于像 <code>struct</code> 或是 <code>enum</code> 这样的类型，本身就不通过引用计数来管理内存，所以也不可能用 <code>weak</code> 这样的 ARC 的概念来进行修饰。</p>
<p>想要在 Swift 中使用 weak delegate，我们就需要将 protocol 限制在 class 内：</p>
<ul>
<li>一种做法是将 protocol 声明为 Objective-C 的，这可以通过在 protocol 前面加上 <code>@objc</code> 关键字来达到，Objective-C 的 protocol 都只有类能实现，因此使用 weak 来修饰就合理了：</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@objc</span> <span class="class"><span class="keyword">protocol</span> <span class="title">MyClassDelegate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>另一种<strong>可能更好</strong>的办法是在 protocol 声明的名字后面加上 <code>class</code>，这可以为编译器显式地指明这个 protocol 只能由 <code>class</code> 来实现，避免了过多的不必要的 Objective-C 兼容：</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">MyClassDelegate</span>: <span class="title">class</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">method</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="可选协议和协议扩展"><a href="#可选协议和协议扩展" class="headerlink" title="可选协议和协议扩展"></a>可选协议和协议扩展</h2><p>Objective-C 中的 protocol 里存在 <code>@optional</code> 关键字，被这个关键字修饰的方法并非必须要被实现，原生的 Swift protocol 里没有可选项，所有定义的方法都是必须实现的，如果不是实现是无法编译的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>,<span class="title">MyProtocol</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译失败</span></span><br><span class="line"><span class="comment">// Type 'ViewController' does not conform to protocol 'MyProtocol'</span></span><br></pre></td></tr></table></figure>
<p>如果我们想要像 Objective-C 里那样定义可选的协议方法，就需要将协议本身和可选方法都定义为 Objective-C 的，也即在 protocol 定义之前加上 <code>@objc</code>，方法之前加上 <code>@objc optional</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@objc</span> <span class="class"><span class="keyword">protocol</span> <span class="title">MyProtocol</span> </span>&#123;</span><br><span class="line">    <span class="meta">@objc</span> <span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">myMethod</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，对于所有的声明，它们的前缀修饰是完全分开的，也就是说你不能像是在 Objective-C 里那样用一个 <code>@optional</code> 指定接下来的若干个方法都是可选的了，必须对每一个可选方法添加前缀，对于没有前缀的方法来说，它们是默认必须实现的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@objc</span> <span class="class"><span class="keyword">protocol</span> <span class="title">MyProtocol</span> </span>&#123;</span><br><span class="line">    <span class="meta">@objc</span> <span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">optionalMethod</span><span class="params">()</span></span>        <span class="comment">// 可选</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">necessaryMethod</span><span class="params">()</span></span>                      <span class="comment">// 必须</span></span><br><span class="line">    <span class="meta">@objc</span> <span class="keyword">optional</span> <span class="function"><span class="keyword">func</span> <span class="title">anotherOptionalMethod</span><span class="params">()</span></span> <span class="comment">// 可选</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>一个不可避免的限制是</strong>，使用 <code>@objc</code> 修饰的 protocol 就只能被 <code>class</code> 实现了，也就是说，对于 <code>struct</code> 和 <code>enum</code> 类型，我们是无法令它们所实现的协议中含有可选方法或者属性的。另外，实现它的 <code>class</code> 中的方法还必须也被标注为 <code>@objc</code>，或者整个类就是继承自 <code>NSObject</code>。对于这种问题，在 Swift 2.0 中，我们有了另一种选择，那就是使用 <strong>protocol extension</strong>。我们可以在声明一个 protocol 之后再用 extension 的方式给出部分方法<strong>默认的实现</strong>，这样这些方法在实际的类中就是可选实现的了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">MyProtocol</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">optionalMethod</span><span class="params">()</span></span>        <span class="comment">// 可选</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">necessaryMethod</span><span class="params">()</span></span>       <span class="comment">// 必须</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">anotherOptionalMethod</span><span class="params">()</span></span> <span class="comment">// 可选</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MyProtocol</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//默认的可选实现</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">optionalMethod</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"optionalMethod"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//默认的可选实现</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">anotherOptionalMethod</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"anotherOptionalMethod"</span>)</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span>,<span class="title">MyProtocol</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 必须的实现</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">necessaryMethod</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"necessaryMethod"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">self</span>.optionalMethod();</span><br><span class="line">        <span class="keyword">self</span>.necessaryMethod();</span><br><span class="line">        <span class="keyword">self</span>.anotherOptionalMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// optionalMethod</span></span><br><span class="line"><span class="comment">// necessaryMethod</span></span><br><span class="line"><span class="comment">// necessaryMethod</span></span><br></pre></td></tr></table></figure>
<h2 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h2><p>Swift 中的单例非常简单，Swift 1.2 以及之后：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">let</span> sharedInstance = <span class="type">Singleton</span>()</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">init</span>() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种写法不但是线程安全的，也是懒加载的，<code>let</code> 定义的属性本身就是线程安全的，同时 <code>static</code> 定义的是一个 class constant，拥有全局作用域和懒加载特性。</p>
<p>另外，这个类型中加入了一个私有的初始化方法，来覆盖默认的公开初始化方法，这让项目中的其他地方不能够通过 init 来生成自己的 <code>Singleton</code> 实例，也保证了类型单例的唯一性。如果你需要的是类似 default 的形式的单例 (也就是说这个类的使用者可以创建自己的实例) 的话，可以去掉这个私有的 <code>init</code> 方法。</p>
<h2 id="输出格式化"><a href="#输出格式化" class="headerlink" title="输出格式化"></a>输出格式化</h2><p>在 Objective-C 中的 <code>%@</code> 这样的格式在指定的位置设定占位符，然后通过参数的方式将实际要输出的内容补充完整。例如 Objective-C 中常用的向控制台输出的 <code>NSLog</code> 方法就使用了这种格式化方法：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">float a = <span class="number">1.234567</span>;</span><br><span class="line"><span class="type">NSString</span> *b = @<span class="string">"Helllo"</span>;</span><br><span class="line"><span class="type">NSLog</span>(@<span class="string">"float：%.2f  str：%p"</span>,a,b);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// float：1.23  str：0x1024a1078</span></span><br></pre></td></tr></table></figure>
<p>对应 Swift 中我们可以这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1.234567</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="string">"Helllo"</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">c</span> = <span class="type">String</span>(format:<span class="string">"float：%.2f str：%p"</span>,a,b)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">c</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// float：1.23 str：0x604000249e10</span></span><br></pre></td></tr></table></figure>
<h2 id="1.1.6"> Selector </h2>

<p><code>@selector</code> 是 Objective-C 时代的一个关键字，它可以将一个方法转换并赋值给一个 SEL 类型，它的表现很类似一个动态的函数指针。在 Swift 中没有 <code>@selector</code> 了，取而代之，从 Swift 2.2 开始我们使用 <code>#selector</code> 来从暴露给 Objective-C 的代码中获取一个 <code>selector</code>，并且因为 <code>selector</code> 是 Objective-C runtime 的概念，在 Swift 4 中，默认情况下所有的 Swift 方法在 Objective-C 中都是不可见的，所以你需要在这类方法前面加上 <code>@objc</code> 关键字，将这个方法暴露给 Objective-C，才能进行使用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="type">UIButton</span>.<span class="keyword">init</span>(type: .system)</span><br><span class="line">btn.backgroundColor = <span class="type">UIColor</span>.red</span><br><span class="line">btn.frame = <span class="type">CGRect</span>(x: <span class="number">100</span>, y: <span class="number">100</span>, width: <span class="number">150</span>, height: <span class="number">40</span>)</span><br><span class="line">btn.setTitle(<span class="string">"Button"</span>, <span class="keyword">for</span>: .normal)</span><br><span class="line"><span class="comment">//无参数</span></span><br><span class="line">btn.addTarget(<span class="keyword">self</span>, action: #selector(btnClick), <span class="keyword">for</span>: .touchUpInside)</span><br><span class="line">view.addSubview(btn)</span><br><span class="line"></span><br><span class="line"><span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">btnClick</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"button click !"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">//有参数</span></span><br><span class="line">btn.addTarget(<span class="keyword">self</span>, action: #selector(btnClick(<span class="number">_</span> :)), <span class="keyword">for</span>: .touchUpInside)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">btnClick</span><span class="params">(<span class="number">_</span> button: UIButton)</span></span>  &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"button click !"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="将-protocol-的方法声明为-mutating"><a href="#将-protocol-的方法声明为-mutating" class="headerlink" title="将 protocol 的方法声明为 mutating"></a>将 protocol 的方法声明为 mutating</h2><p>Swift 的 protocol 不仅可以被 class 类型实现，也适用于 <code>struct</code> 和 <code>enum</code>，因为这个原因，我们在写给别人用的协议时需要多考虑是否使用 <code>mutating</code> 来修饰方法。Swift 的 <code>mutating</code> 关键字修饰方法是为了能在该方法中修改 <code>struct</code> 或是 <code>enum</code> 的变量，所以如果你没在协议方法里写 <code>mutating</code> 的话，别人如果用 <code>struct</code> 或者 <code>enum</code> 来实现这个协议的话，就不能在方法里改变自己的变量了，比如下面的代码是编译不过的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">changeColor</span><span class="params">()</span></span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyCar</span>: <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> color = <span class="string">"blue"</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">changeColor</span><span class="params">()</span></span> &#123;</span><br><span class="line">        color = <span class="string">"red"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译失败</span></span><br><span class="line"><span class="comment">// Cannot assign to property: 'self' is immutable</span></span><br></pre></td></tr></table></figure>
<p>我们应该加上 <code>mutating</code> 关键字：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">changeColor</span><span class="params">()</span></span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyCar</span>: <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> color = <span class="string">"blue"</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">changeColor</span><span class="params">()</span></span> &#123;</span><br><span class="line">        color = <span class="string">"red"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> car = <span class="type">MyCar</span>()</span><br><span class="line">    <span class="built_in">print</span>(car.color)</span><br><span class="line">    car.changeColor()</span><br><span class="line">    <span class="built_in">print</span>(car.color)    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// blue</span></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// red</span></span><br></pre></td></tr></table></figure>
<h2 id="数组遍历-enumerate"><a href="#数组遍历-enumerate" class="headerlink" title="数组遍历 enumerate"></a>数组遍历 enumerate</h2><p>使用 NSArray 时一个很常遇见的的需求是在枚举数组内元素的同时也想使用对应的<strong>下标索引</strong>，在 Objective-C 中最方便的方式是使用 NSArray 的 <code>enumerateObjectsUsingBlock:</code> ，在 Swift 中存在一个效率，安全性和可读性都很好的替代，那就是快速枚举某个数组的<code>EnumerateGenerator</code>，它的元素是同时包含了元素下标索引以及元素本身的多元组：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>,<span class="string">"e"</span>]</span><br><span class="line"><span class="keyword">for</span> (idx, str) <span class="keyword">in</span> arr.enumerated() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"idx: \(idx) str: \(str)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line">idx: <span class="number">0</span> str: a</span><br><span class="line">idx: <span class="number">1</span> str: b</span><br><span class="line">idx: <span class="number">2</span> str: <span class="built_in">c</span></span><br><span class="line">idx: <span class="number">3</span> str: d</span><br><span class="line">idx: <span class="number">4</span> str: e</span><br></pre></td></tr></table></figure>
<h2 id="输入输出参数-inout"><a href="#输入输出参数-inout" class="headerlink" title="输入输出参数 inout"></a>输入输出参数 inout</h2><p>函数参数默认是<strong>常量</strong>，如果试图在函数体中更改参数值将会导致<strong>编译错误</strong>，比如下面的例子中尝试着交换值：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapTwoInts</span><span class="params">(<span class="number">_</span> a: Int, <span class="number">_</span> b: Int)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> temporaryA = a</span><br><span class="line">    a = b</span><br><span class="line">    b = temporaryA</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译失败</span></span><br><span class="line"><span class="comment">// Cannot assign to value: 'a' is a 'let' constant</span></span><br><span class="line"><span class="comment">// Cannot assign to value: 'b' is a 'let' constant</span></span><br></pre></td></tr></table></figure>
<p>如果想要一个函数可以修改参数的值，并且想要在这些修改在函数调用结束后仍然存在，那么就应该把这个参数定义为输入输出参数（In-Out Parameters）：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swapTwoInts</span><span class="params">(<span class="number">_</span> a: <span class="keyword">inout</span> Int, <span class="number">_</span> b: <span class="keyword">inout</span> Int)</span></span> &#123;</span><br><span class="line">    <span class="keyword">let</span> temporaryA = a</span><br><span class="line">    a = b</span><br><span class="line">    b = temporaryA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Default-参数"><a href="#Default-参数" class="headerlink" title="Default 参数"></a>Default 参数</h2><p>Swift 的方法是支持默认参数的，也就是说在声明方法时，可以给某个参数指定一个默认使用的值。在调用该方法时要是传入了这个参数，则使用传入的值，如果缺少这个输入参数，那么直接使用设定的默认值进行调用。和其他很多语言的默认参数相比较，Swift 中的默认参数限制更少，并没有所谓 “默认参数之后不能再出现无默认值的参数” 这样的规则，举个例子，下面两种方法的声明在 Swift 里都是合法可用的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello1</span><span class="params">(str1: String = <span class="string">"Hello"</span>, str2: String, str3: String)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(str1 + str2 + str3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sayHello2</span><span class="params">(str1: String, str2: String, str3: String = <span class="string">"World"</span>)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(str1 + str2 + str3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sayHello1(str2: <span class="string">" "</span>, str3: <span class="string">"World"</span>)</span><br><span class="line">sayHello2(str1: <span class="string">"Hello"</span>, str2: <span class="string">" "</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出都是 Hello World</span></span><br></pre></td></tr></table></figure>
<h2 id="延迟加载-lazy"><a href="#延迟加载-lazy" class="headerlink" title="延迟加载 lazy"></a>延迟加载 lazy</h2><p>延时加载或者说延时初始化是很常用的优化方法，在构建和生成新的对象的时候，内存分配会在运行时耗费不少时间，<strong>如果有一些对象的属性和内容非常复杂的话，这个时间更是不可忽略</strong>。另外，有些情况下我们并不会立即用到一个对象的所有属性，而默认情况下初始化时，<strong>那些在特定环境下不被使用的存储属性，也一样要被初始化和赋值</strong>，也是一种浪费。在 Objective-C 中，一个延迟加载一般是这样的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ClassA.h</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *testString;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ClassA.m</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)testString &#123;</span><br><span class="line">     <span class="keyword">if</span> (!_testString) &#123;</span><br><span class="line">         _testString = <span class="string">@"Hello"</span>;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"只在首次访问输出"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> _testString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应在 Swift 中，使用 <code>lazy</code> 作为属性修饰符时，只能声明属性是<strong>变量</strong>，且我们需要显式地指定<strong>属性类型</strong>，否则会编译错误：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> </span>&#123;</span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">let</span> str: <span class="type">String</span> = &#123;</span><br><span class="line">        <span class="keyword">let</span> str = <span class="string">"Hello"</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"只在首次访问输出"</span>)</span><br><span class="line">        <span class="keyword">return</span> str</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译失败</span></span><br><span class="line"><span class="comment">// 'lazy' cannot be used on a let</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> </span>&#123;</span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> str = &#123;</span><br><span class="line">        <span class="keyword">let</span> str = <span class="string">"Hello"</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"只在首次访问输出"</span>)</span><br><span class="line">        <span class="keyword">return</span> str</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译失败</span></span><br><span class="line"><span class="comment">// Unable to infer complex closure return type</span></span><br></pre></td></tr></table></figure>
<p>我们应该声明为 <code>var</code> 并指定好类型：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassA</span> </span>&#123;</span><br><span class="line">    <span class="built_in">lazy</span> <span class="keyword">var</span> str: <span class="type">String</span> = &#123;</span><br><span class="line">        <span class="keyword">let</span> str = <span class="string">"Hello"</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"只在首次访问输出"</span>)</span><br><span class="line">        <span class="keyword">return</span> str</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> ca = <span class="type">ClassA</span>()</span><br><span class="line">    <span class="built_in">print</span>(ca.str)</span><br><span class="line">    <span class="built_in">print</span>(ca.str)</span><br><span class="line">    <span class="built_in">print</span>(ca.str)   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 只在首次访问输出</span></span><br><span class="line"><span class="comment">// Hello</span></span><br><span class="line"><span class="comment">// Hello</span></span><br><span class="line"><span class="comment">// Hello</span></span><br></pre></td></tr></table></figure>
<p>如果不需要做什么额外工作的话，也可以对这个 <code>lazy</code> 的属性直接写赋值语句：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">lazy</span> <span class="keyword">var</span> str: <span class="type">String</span> = <span class="string">"Hello"</span></span><br></pre></td></tr></table></figure>
<p>我们还可以利用 <code>lazy</code> 配合像 <code>map</code> 或是 <code>filter</code> 这类接受闭包并进行运行的方法一起，<strong>让整个行为变成延时进行的</strong>。在某些情况下这么做也对性能会有不小的帮助。例如，直接使用 map 时：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = <span class="number">1</span>...<span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> result = data.<span class="built_in">map</span> &#123;</span><br><span class="line">    (i: <span class="type">Int</span>) -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"正在处理 \(i)"</span>)</span><br><span class="line">    <span class="keyword">return</span> i * <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"准备访问结果"</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> result &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"操作后结果为 \(i)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"操作完毕"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 正在处理 1</span></span><br><span class="line"><span class="comment">// 正在处理 2</span></span><br><span class="line"><span class="comment">// 正在处理 3</span></span><br><span class="line"><span class="comment">// 准备访问结果</span></span><br><span class="line"><span class="comment">// 操作后结果为 2</span></span><br><span class="line"><span class="comment">// 操作后结果为 4</span></span><br><span class="line"><span class="comment">// 操作后结果为 6</span></span><br><span class="line"><span class="comment">// 操作完毕</span></span><br></pre></td></tr></table></figure>
<p>而如果我们先进行一次 <code>lazy</code> 操作的话，我们就能得到延时运行版本的容器：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = <span class="number">1</span>...<span class="number">3</span></span><br><span class="line"><span class="keyword">let</span> result = data.<span class="built_in">lazy</span>.<span class="built_in">map</span> &#123;</span><br><span class="line">    (i: <span class="type">Int</span>) -&gt; <span class="type">Int</span> <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"正在处理 \(i)"</span>)</span><br><span class="line">    <span class="keyword">return</span> i * <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"准备访问结果"</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> result &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"操作后结果为 \(i)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"操作完毕"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 准备访问结果</span></span><br><span class="line"><span class="comment">// 正在处理 1</span></span><br><span class="line"><span class="comment">// 操作后结果为 2</span></span><br><span class="line"><span class="comment">// 正在处理 2</span></span><br><span class="line"><span class="comment">// 操作后结果为 4</span></span><br><span class="line"><span class="comment">// 正在处理 3</span></span><br><span class="line"><span class="comment">// 操作后结果为 6</span></span><br><span class="line"><span class="comment">// 操作完毕</span></span><br></pre></td></tr></table></figure>
<p>对于那些不需要完全运行，可能提前退出的情况，使用 lazy 来进行性能优化效果会非常有效。</p>
<h2 id="编译标记"><a href="#编译标记" class="headerlink" title="编译标记"></a>编译标记</h2><p>在 Objective-C 中，我们经常在代码中插入 <code>#param</code> 符号来标记代码的区间，这样在 Xcode 的导航栏中我们就可以看到组织分块后的方法列表。在 Swift 中我们可以用 <code>MARK:</code> 来代替：</p>
<p><img src="http://p0kmbfoc8.bkt.clouddn.com/Snip20171207_3.png" alt=""></p>
<p>在 Objective-C 中还有一个很常用的编译标记，那就是 <code>#warning</code>，一个 <code>#warning</code> 标记可以在 Xcode 的代码编辑器中显示为明显的黄色警告条，非常适合用来提示代码的维护者和使用者需要对某些东西加以关注。在 Swift 中我们可以用 <code>FIXME:</code> 和 <code>TODO:</code> 配合 <code>shell</code> 来代替：</p>
<p><img src="http://p0kmbfoc8.bkt.clouddn.com/Snip20171207_8.png" alt=""></p>
<p>脚本：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TAGS="TODO:|FIXME:"</span><br><span class="line">echo "searching $&#123;SRCROOT&#125; for $&#123;TAGS&#125;"</span><br><span class="line">find "$&#123;SRCROOT&#125;" \( -name "*.swift" \) -print0 | xargs -0 egrep --with-filename --line-number --only-matching "($TAGS).*\$" | perl -p -e "s/($TAGS)/ warning: \$1/"</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<p><img src="http://p0kmbfoc8.bkt.clouddn.com/Snip20171207_7.png" alt=""><br><img src="http://p0kmbfoc8.bkt.clouddn.com/Snip20171207_6.png" alt=""></p>
<h2 id="换行符"><a href="#换行符" class="headerlink" title="换行符"></a>换行符</h2><p>在 Swift 3 中，需要换行时是需要 <code>\n</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"xxxx\nxxx"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// xxxx</span></span><br><span class="line"><span class="comment">// xxx</span></span><br></pre></td></tr></table></figure>
<p>在 swift 4 中，我们可以使用 <code>&quot;&quot;&quot;</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> jsonStr = <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            "</span>id<span class="string">": 123455,</span></span><br><span class="line"><span class="string">            "</span>nickname<span class="string">": "</span>xxxx<span class="string">",</span></span><br><span class="line"><span class="string">            "</span>isMale<span class="string">": true,</span></span><br><span class="line"><span class="string">            "</span>birthday<span class="string">": "</span><span class="number">2000</span>年<span class="number">3</span>月<span class="number">24</span>日<span class="string">",</span></span><br><span class="line"><span class="string">            "</span>personalURL<span class="string">": "</span>https:<span class="comment">//xxxxxx.github.io"</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">          </span></span><br><span class="line"><span class="string">// 输出：</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    "</span>id<span class="string">": 123455,</span></span><br><span class="line"><span class="string">    "</span>nickname<span class="string">": "</span>xxxx<span class="string">",</span></span><br><span class="line"><span class="string">    "</span>isMale<span class="string">": true,</span></span><br><span class="line"><span class="string">    "</span>birthday<span class="string">": "</span><span class="number">2000</span>年<span class="number">3</span>月<span class="number">24</span>日<span class="string">",</span></span><br><span class="line"><span class="string">    "</span>personalURL<span class="string">": "</span>https:<span class="comment">//xxxxxx.github.io"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符串切割-split"><a href="#字符串切割-split" class="headerlink" title="字符串切割 split"></a>字符串切割 split</h2><p>我们需要切割某个字符串时可以用 <code>split</code> 方法，需要注意的是，返回的结果是个<strong>数组</strong>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"Hello，world !"</span></span><br><span class="line"><span class="built_in">print</span>(str.<span class="built_in">split</span>(separator: <span class="string">"，"</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// ["Hello", "world !"]</span></span><br></pre></td></tr></table></figure>
<h2 id="KVC"><a href="#KVC" class="headerlink" title="KVC"></a>KVC</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"ifelseboyxx"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Swift 4 中 Apple 引入了新的 KeyPath 的表达方式，现在，对于类型 <code>MyClass</code> 中的<strong>变量</strong> <code>name</code>，对应的 KeyPath 可以写为 <code>\MyClass.name</code>，利用 KVC 修改 <code>name</code> 值的话，我们可以这么操作：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> object = <span class="type">MyClass</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"name: \(object.name)"</span>)</span><br><span class="line"><span class="comment">// set</span></span><br><span class="line">object[keyPath: \<span class="type">MyClass</span>.name] = <span class="string">"ifelseboy"</span></span><br><span class="line"><span class="comment">// get</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"name: \(object[keyPath: \MyClass.name])"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// name: ifelseboyxx</span></span><br><span class="line"><span class="comment">// name: ifelseboy</span></span><br></pre></td></tr></table></figure>
<p>另外 Swift 4 中 <code>struct</code> 同样支持 KVC ：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="type">MyStruct</span>(age: <span class="number">18</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"我今年 \(obj.age) 岁了"</span>)</span><br><span class="line">obj[keyPath: \<span class="type">MyStruct</span>.age] = <span class="number">8</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"我今年 \(obj[keyPath: \MyStruct.age]) 岁了"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 我今年 18 岁了</span></span><br><span class="line"><span class="comment">// 我今年 8 岁了</span></span><br></pre></td></tr></table></figure>
<h2 id="1.2.6"> Swift 中值类型和引用类型注意点 </h2>

<p>KVC 一节中代码里有个注意点：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="type">MyStruct</span>(age: <span class="number">18</span>)</span><br><span class="line"><span class="comment">//替换为</span></span><br><span class="line"><span class="keyword">let</span> obj = <span class="type">MyStruct</span>(age: <span class="number">18</span>)</span><br></pre></td></tr></table></figure>
<p>是编译不过的，会报错：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Cannot</span> assign to immutable expression of type '<span class="type">Int'</span></span><br></pre></td></tr></table></figure>
<p>笔者初次也犯了这样的错误，想当然的认为 <code>MyClass</code> 用 <code>let</code> 声明的是没有问题的，<code>struct</code> 也一样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> object = <span class="type">MyClass</span>()</span><br></pre></td></tr></table></figure>
<p><strong>其实原因很简单，swift 中 Class 是引用类型的，而 struct 是值类型的：值类型在被赋给一个变量，或被传给函数时，实际是做了一次拷贝。引用类型在被赋给一个变量，或被传给函数时，传递的是引用。</strong></p>
<h2 id="KVO"><a href="#KVO" class="headerlink" title="KVO"></a>KVO</h2><p>很遗憾，依然只有 <code>NSObject</code> 才能支持 KVO，另外由于 Swift 为了效率，默认禁用了动态派发，因此想用 Swift 来实现 KVO，我们还需要做额外的工作，那就是将想要观测的对象标记为 <code>dynamic</code> 和 <code>@objc</code>，下面的 🌰 是 <code>ViewController</code> 监听 <code>MyClass</code> 的 <code>date</code> 属性：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@objc</span> <span class="keyword">dynamic</span> <span class="keyword">var</span> date = <span class="type">Date</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> myObject: <span class="type">MyClass</span>!</span><br><span class="line">    <span class="keyword">var</span> observation: <span class="type">NSKeyValueObservation</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">        myObject = <span class="type">MyClass</span>()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"当前日期：\(myObject.date)"</span>)</span><br><span class="line">    </span><br><span class="line">        observation = myObject.observe(\<span class="type">MyClass</span>.date, options: [.old,.new], changeHandler: &#123; (<span class="number">_</span>, change) <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> newDate = change.newValue , <span class="keyword">let</span> oldDate = change.oldValue &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"日期发生变化 old：\(oldDate) new：\(newDate) "</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: <span class="type">DispatchTime</span>.now() + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.myObject.date = <span class="type">Date</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 当前日期：2017-12-07 06:31:26 +0000</span></span><br><span class="line"><span class="comment">// 日期发生变化 old：2017-12-07 06:31:26 +0000 new：2017-12-07 06:31:27 +0000</span></span><br></pre></td></tr></table></figure>
<p>在 Objective-C 中我们几乎可以没有限制地对所有满足 KVC 的属性进行监听，<strong>而现在我们需要属性有 <code>dynamic</code> 和 <code>@objc</code> 进行修饰</strong>。大多数情况下，我们想要观察的类包含这两个修饰 (除非这个类的开发者有意为之，否则一般也不会有人愿意多花功夫在属性前加上它们，因为这毕竟要损失一部分性能)，并且有时候我们很可能也无法修改想要观察的类的源码。遇到这样的情况的话，<strong>一个可能可行的方案是继承这个类并且将需要观察的属性使用 <code>dynamic</code> 和 <code>@objc</code> 进行重写</strong>。比如刚才我们的 <code>MyClass</code> 中如果 <code>date</code> <strong>没有相应标注的话</strong>，我们可能就需要一个新的 <code>MyChildClass</code>了： </p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>: <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> date = <span class="type">Date</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyChildClass</span>: <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="meta">@objc</span> <span class="keyword">dynamic</span> <span class="keyword">override</span> <span class="keyword">var</span> date: <span class="type">Date</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> <span class="keyword">super</span>.date &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; <span class="keyword">super</span>.date = newValue &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> myObject: <span class="type">MyChildClass</span>!</span><br><span class="line">    <span class="keyword">var</span> observation: <span class="type">NSKeyValueObservation</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        </span><br><span class="line">        myObject = <span class="type">MyChildClass</span>()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"当前日期：\(myObject.date)"</span>)</span><br><span class="line">    </span><br><span class="line">        observation = myObject.observe(\<span class="type">MyChildClass</span>.date, options: [.old,.new], changeHandler: &#123; (<span class="number">_</span>, change) <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> newDate = change.newValue , <span class="keyword">let</span> oldDate = change.oldValue &#123;</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"日期发生变化 old：\(oldDate) new：\(newDate) "</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: <span class="type">DispatchTime</span>.now() + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.myObject.date = <span class="type">Date</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 当前日期：2017-12-07 06:36:50 +0000</span></span><br><span class="line"><span class="comment">// 日期发生变化 old：2017-12-07 06:36:50 +0000 new：2017-12-07 06:36:51 +0000</span></span><br></pre></td></tr></table></figure>
<h2 id="Swift-UIButton-状态的叠加"><a href="#Swift-UIButton-状态的叠加" class="headerlink" title="Swift UIButton 状态的叠加"></a>Swift UIButton 状态的叠加</h2><p>在 Objective-C 中，如果我们想叠加按钮的某个状态，可以这么写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIButton</span> * button = [<span class="built_in">UIButton</span> buttonWithType:<span class="built_in">UIButtonTypeCustom</span>];</span><br><span class="line">[button setTitle:<span class="string">@"Test"</span> forState:<span class="built_in">UIControlStateNormal</span> | <span class="built_in">UIControlStateSelected</span>];</span><br></pre></td></tr></table></figure>
<p>对应的 Swift 我们可以这么写：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> btn = <span class="type">UIButton</span>.<span class="keyword">init</span>(type: .custom)</span><br><span class="line">btn.setTitle(<span class="string">"hehe"</span>, <span class="keyword">for</span>: [.normal ,.selected])</span><br></pre></td></tr></table></figure>
<p>把需要叠加的状态用个<strong>数组</strong>装起来就行了。</p>
<h2 id="Swift-中的-“-synchronized”"><a href="#Swift-中的-“-synchronized”" class="headerlink" title="Swift 中的 “@synchronized”"></a>Swift 中的 “@synchronized”</h2><p>在 Objective-C 中，我们可以用 <code>@synchronized</code> 这个关键字可以用来修饰一个变量，并为其自动加上和解除互斥锁。这样，可以保证变量在作用范围内不会被其他线程改变：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)myMethod:(<span class="keyword">id</span>)anObj &#123;</span><br><span class="line">    <span class="keyword">@synchronized</span>(anObj) &#123;</span><br><span class="line">        <span class="comment">// 在括号内持有 anObj 锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然这个方法很简单好用，但是很不幸的是在 Swift 中它已经 (或者是暂时) 不存在了。其实 <code>@synchronized</code> 在幕后做的事情是调用了 <code>objc_sync</code> 中的 <code>objc_sync_enter</code> 和 <code>objc_sync_exit</code> 方法，并且加入了一些异常判断。因此，在 Swift 中，如果我们忽略掉那些异常的话，我们想要 lock 一个变量的话，可以这样写：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myMethod</span><span class="params">(anObj: AnyObject!)</span></span> &#123;</span><br><span class="line">    objc_sync_enter(anObj)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 enter 和 exit 之间持有 anObj 锁</span></span><br><span class="line"></span><br><span class="line">    objc_sync_exit(anObj)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更进一步，如果我们喜欢以前的那种形式，甚至可以写一个全局的方法，并接受一个闭包，来将 <code>objc_sync_enter</code> 和 <code>objc_sync_exit</code> 封装起来：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">synchronized</span><span class="params">(<span class="number">_</span> lock: AnyObject, closure: <span class="params">()</span></span></span> -&gt; ()) &#123;</span><br><span class="line">    objc_sync_enter(lock)</span><br><span class="line">    closure()</span><br><span class="line">    objc_sync_exit(lock)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用：</span></span><br><span class="line">synchronized(<span class="keyword">self</span>) &#123;</span><br><span class="line">            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样使用起来就和 Objective-C 中 <code>@synchronized</code> 很像了。</p>
<p>再举个 🌰 ，如果我们想为某个类实现一个线程安全的 <code>setter</code>，可以这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obj</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _str = <span class="string">"123"</span></span><br><span class="line">    <span class="keyword">var</span> str: <span class="type">String</span> &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> _str</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;</span><br><span class="line">            synchronized(<span class="keyword">self</span>) &#123;</span><br><span class="line">                _str = newValue</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自定义日志输出"><a href="#自定义日志输出" class="headerlink" title="自定义日志输出"></a>自定义日志输出</h2><p>在 Objective-C 中，我们通常会自定义日志输出来完善信息以及避免 <code>release</code> 下的输出，比如下面这种，可以额外提供行数、方法名等信息：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#ifdef DEBUG</span></span><br><span class="line"><span class="meta">#define XXLog(fmt, ...) NSLog((@<span class="meta-string">"%s [Line %d] "</span> fmt), __PRETTY_FUNCTION__, __LINE__, ##__VA_ARGS__)</span></span><br><span class="line"><span class="meta">#else</span></span><br><span class="line"><span class="meta">#define XXLog(...)</span></span><br><span class="line"><span class="meta">#endif</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</span><br><span class="line">    <span class="comment">// Override point for customization after application launch.</span></span><br><span class="line">    </span><br><span class="line">    XXLog(<span class="string">@"ifelseboyxx"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 2017-12-08 13:32:02.211306+0800 Demo[17902:88775537] -[AppDelegate application:didFinishLaunchingWithOptions:] [Line 28] ifelseboyxx</span></span><br></pre></td></tr></table></figure>
<p>在 Swift 中，我们可以这样自定义：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">xxprint</span>&lt;T&gt;<span class="params">(<span class="number">_</span> message: T, filePath: String = #file, line: Int = #line, function: String = #function)</span></span> &#123;</span><br><span class="line">    #<span class="keyword">if</span> <span class="type">DEBUG</span></span><br><span class="line">        <span class="keyword">let</span> fileName = (filePath <span class="keyword">as</span> <span class="type">NSString</span>).lastPathComponent.replacingOccurrences(of: <span class="string">".Swift"</span>, with: <span class="string">""</span>)</span><br><span class="line">        <span class="keyword">let</span> dateFormatter = <span class="type">DateFormatter</span>()</span><br><span class="line">        dateFormatter.locale = <span class="type">Locale</span>.current</span><br><span class="line">        dateFormatter.dateFormat = <span class="string">"yyyy-MM-dd HH:mm:ss"</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"["</span> + dateFormatter.string(from: <span class="type">Date</span>()) + <span class="string">" "</span> + fileName + <span class="string">" "</span> + function + <span class="string">" \(line)"</span> + <span class="string">"]："</span> + <span class="string">"\(message)"</span>)</span><br><span class="line">    #endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">    </span><br><span class="line">        xxprint(<span class="string">"ifelseboyxx"</span>)</span><br><span class="line">        <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: <span class="type">DispatchTime</span>.now() + <span class="number">1</span>) &#123;</span><br><span class="line">            xxprint(<span class="string">"ifelseboyxx"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// [2017-12-08 13:49:38 ViewController.swift viewDidLoad() 27]：ifelseboyxx</span></span><br><span class="line"><span class="comment">// [2017-12-08 13:49:39 ViewController.swift viewDidLoad() 29]：ifelseboyxx</span></span><br></pre></td></tr></table></figure>
<h2 id="Swift-中的-“readonly”"><a href="#Swift-中的-“readonly”" class="headerlink" title="Swift 中的 “readonly”"></a>Swift 中的 “readonly”</h2><p>在 Objective-C 中，我们通常把属性声明为 <code>readonly</code> 来提醒别人：“不要修改！！”，通常这么写：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>如果外部尝试修改的话，会编译错误：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">   </span><br><span class="line">    Person *p = [Person new];</span><br><span class="line">    p.name = <span class="string">@"ifelseboyxx"</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译错误：</span></span><br><span class="line"><span class="comment">// Assignment to readonly property</span></span><br></pre></td></tr></table></figure>
<p>有些情况下，我们希望内部可以点语法访问 <code>name</code> 属性，也就是 <code>self.name</code>，但是因为是 <code>readonly</code> 的，会编译错误：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name = <span class="string">@"ifelseboyxx"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译错误：</span></span><br><span class="line"><span class="comment">// Assignment to readonly property</span></span><br></pre></td></tr></table></figure>
<p>这时候我们就会在内部的 <code>extension</code> 重新声明一个 <code>readwrite</code>的同样的属性，也就是<strong>“外部只读，内部可写”</strong>：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>在 Swift 中，我们可能有同样的场景。这里就不得不提到 <code>private</code> 和 <code>fileprivate</code> 关键字了。<br><code>private</code>表示声明为私有的实体只能在其声明的范围内被访问。比如我在 <code>MyClass</code> 中声明了一个私有的 <code>name</code> 属性，外部访问的话会编译错误：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> name: <span class="type">String</span> = <span class="string">"Test"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> only = <span class="type">MyClass</span>()</span><br><span class="line">        <span class="built_in">print</span>(only.name) </span><br><span class="line">        only.name = <span class="string">"ifelseboyxxv587"</span>       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译异常：</span></span><br><span class="line"><span class="comment">// 'name' is inaccessible due to 'private' protection level</span></span><br></pre></td></tr></table></figure>
<p>而 <code>fileprivate</code>，看命名我们大概能猜到，就是将对实体的访问权限于它声明的源文件。通俗点讲，比如我上面的代码都是在 <code>ViewController.swift</code> 这个文件里的，我把 <code>private</code> 修改为 <code>fileprivate</code>，就不会编译错误了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">fileprivate</span> <span class="keyword">var</span> name: <span class="type">String</span> = <span class="string">"Test"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么如果非 <code>ViewController.swift</code> 文件，也想访问 <code>MyClass</code> 的 <code>name</code> 属性该怎么办呢？我们可以把 <code>name</code> 属性声明为 <code>fileprivate(set)</code>，就要就达到类似 Objective-C 中的 <code>readonly</code> 效果了 ：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ViewController.swift 文件</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">fileprivate</span>(<span class="keyword">set</span>) <span class="keyword">var</span> name: <span class="type">String</span> = <span class="string">"Test"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> only = <span class="type">MyClass</span>()</span><br><span class="line">        <span class="built_in">print</span>(only.name)</span><br><span class="line">        only.name = <span class="string">"ifelseboyxxv587"</span></span><br><span class="line">        <span class="built_in">print</span>(only.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译正常，ViewController.swift 文件内可读可写</span></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// Test</span></span><br><span class="line"><span class="comment">// ifelseboyxxv587</span></span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AppDelegate.swift 文件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">application</span><span class="params">(<span class="number">_</span> application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="comment">// Override point for customization after application launch.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> only = <span class="type">MyClass</span>()</span><br><span class="line">    <span class="built_in">print</span>(only.name) <span class="comment">//只能读</span></span><br><span class="line">    only.name = <span class="string">"ifelseboyxxv587"</span> <span class="comment">//这里报错，不能写</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译异常：</span></span><br><span class="line"><span class="comment">// Cannot assign to property: 'name' setter is inaccessible</span></span><br></pre></td></tr></table></figure>
<h2 id="作用域：do-语句块"><a href="#作用域：do-语句块" class="headerlink" title="作用域：do 语句块"></a>作用域：do 语句块</h2><p>在 Objective-C 中，我们可以利用 <code>{}</code> 来开辟新的作用域，来避免对象名称重复的问题：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *ha = <span class="string">@"测试一"</span>;</span><br><span class="line">    </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *ha = <span class="string">@"测试二"</span>;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,ha);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,ha);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 2017-12-11 16:55:20.303132+0800 Demo[48418:93027416] 测试二</span></span><br><span class="line"><span class="comment">// 2017-12-11 16:55:20.303316+0800 Demo[48418:93027416] 测试一</span></span><br></pre></td></tr></table></figure>
<p>在 Swift 中，取代 <code>{}</code> 的是 <code>do {}</code>：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ha = <span class="string">"测试一"</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> ha = <span class="string">"测试二"</span></span><br><span class="line">    <span class="built_in">print</span>(ha)</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="built_in">print</span>(ha)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 测试二</span></span><br><span class="line"><span class="comment">// 测试一</span></span><br></pre></td></tr></table></figure>
<h2 id="倒序-reversed"><a href="#倒序-reversed" class="headerlink" title="倒序 reversed()"></a>倒序 reversed()</h2><p>在 Objective-C 中，我们如果想倒序数组一般这样：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *array = @[<span class="string">@"1"</span>,<span class="string">@"2"</span>,<span class="string">@"3"</span>];</span><br><span class="line">    </span><br><span class="line"><span class="built_in">NSArray</span> *reversedArray = [[array reverseObjectEnumerator] allObjects];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 2017-12-11 17:39:57.127466+0800 Demo[49004:93210504] (</span></span><br><span class="line">    <span class="number">3</span>,</span><br><span class="line">    <span class="number">2</span>,</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>在 Swift 中，相对简单点：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr:[<span class="type">String</span>] = [<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>]</span><br><span class="line"><span class="keyword">let</span> reversedArr:[<span class="type">String</span>] = arr.reversed()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// ["3", "2", "1"]</span></span><br></pre></td></tr></table></figure>
<h2 id="标签语句：指定跳出某个条件语句"><a href="#标签语句：指定跳出某个条件语句" class="headerlink" title="标签语句：指定跳出某个条件语句"></a>标签语句：指定跳出某个条件语句</h2><p>在 Objective-C 中，如果遇到多层嵌套的条件语句，我们如果想要指定跳出某个条件语句是很不方便的。比如有两个循环，<strong>一旦找到它们相同的，就立刻停止循环</strong>，我们可能会这么做：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *arr1 = @[<span class="string">@"1"</span>,<span class="string">@"2"</span>,<span class="string">@"3"</span>,<span class="string">@"4"</span>,<span class="string">@"5"</span>];</span><br><span class="line"><span class="built_in">NSArray</span> *arr2 = @[<span class="string">@"4"</span>,<span class="string">@"6"</span>,<span class="string">@"8"</span>,<span class="string">@"9"</span>,<span class="string">@"2"</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">BOOL</span> finded = <span class="literal">NO</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSString</span> *x <span class="keyword">in</span> arr1) &#123;</span><br><span class="line">    <span class="keyword">if</span> (finded) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"x：%@"</span>,x);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *y <span class="keyword">in</span> arr2) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"y：%@"</span>,y);</span><br><span class="line">        <span class="keyword">if</span> ([x isEqualToString:y]) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"找到相等的了：%@"</span>,x);</span><br><span class="line">            finded = <span class="literal">YES</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们需要借助 <code>finded</code> 这个 <code>BOOL</code>，来方便我们跳出循环。在 Swift 中，我们就可以利用标签语句，来指定具体跳出哪个循环，语法是这样的：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">标签名: 条件语句 &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的 🌰 我们可以这么写：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>,<span class="string">"4"</span>,<span class="string">"5"</span>]</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="string">"4"</span>,<span class="string">"6"</span>,<span class="string">"8"</span>,<span class="string">"9"</span>,<span class="string">"2"</span>]</span><br><span class="line">        </span><br><span class="line">label: <span class="keyword">for</span> x <span class="keyword">in</span> arr1 &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"x： \(x)"</span>)</span><br><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> arr2 &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"y： \(y)"</span>)</span><br><span class="line">        <span class="keyword">if</span> x == y &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"找到相等的了：\(y)"</span>)</span><br><span class="line">            <span class="keyword">break</span> label</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码，我们把第一层循环定义了标签：<code>label</code>。在第二层循环中，一旦条件成立，立刻跳出第一层循环 <code>label</code>。这个特性，可以说十分方便了！</p>
<h2 id="优雅的定义通知名称"><a href="#优雅的定义通知名称" class="headerlink" title="优雅的定义通知名称"></a>优雅的定义通知名称</h2><p>在 Objective-C 中，我们自定义通知时，对于名称的定义一般都有规范：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// xxx.h </span></span><br><span class="line"><span class="built_in">UIKIT_EXTERN</span> <span class="built_in">NSString</span> * <span class="keyword">const</span> XXXXNotification;</span><br><span class="line"></span><br><span class="line"><span class="comment">// xxx.m </span></span><br><span class="line"><span class="built_in">NSString</span> * <span class="keyword">const</span> XXXXNotification = <span class="string">@"XXXXNotification"</span>;</span><br></pre></td></tr></table></figure>
<p>在 Swift 中，我们可以参考 <a href="https://github.com/Alamofire/Alamofire" target="_blank" rel="noopener">Alamofire</a> 的方式，创建个专门存放通知名的文件，扩展 <code>Notification.Name</code> 并以结构体 <code>struct</code> 方式声明：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// XXNotification.swift 文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Notification</span>.<span class="title">Name</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Task</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">let</span> 通知名 = <span class="type">Notification</span>.<span class="type">Name</span>(rawValue: <span class="string">"org.target名称.notification.name.task.通知名"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们就可以愉快的使用了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add</span></span><br><span class="line"><span class="type">NotificationCenter</span>.<span class="keyword">default</span>.addObserver(<span class="keyword">self</span>, selector: #selector(myNotification(<span class="number">_</span> :)), name: <span class="type">NSNotification</span>.<span class="type">Name</span>.<span class="type">Task</span>.通知名, object: <span class="keyword">self</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// post</span></span><br><span class="line"><span class="type">NotificationCenter</span>.<span class="keyword">default</span>.post(name: <span class="type">NSNotification</span>.<span class="type">Name</span>.<span class="type">Task</span>.通知名, object: <span class="keyword">self</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// remove</span></span><br><span class="line"><span class="type">NotificationCenter</span>.<span class="keyword">default</span>.removeObserver(<span class="keyword">self</span>, name: <span class="type">NSNotification</span>.<span class="type">Name</span>.<span class="type">Task</span>.通知名, object: <span class="keyword">self</span>)</span><br></pre></td></tr></table></figure>
<h2 id="weakSelf-和-strongSelf"><a href="#weakSelf-和-strongSelf" class="headerlink" title="weakSelf 和 strongSelf"></a>weakSelf 和 strongSelf</h2><p>在 Objective-C 中，为了防止 block 循环引用，我们通用利用 <code>__weak</code> 和 <code>__strong</code>  搭配使用：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line"> </span><br><span class="line">__<span class="keyword">strong</span> <span class="keyword">typeof</span>(weakSelf) strongSelf = weakSelf;</span><br></pre></td></tr></table></figure>
<p>对应的 Swift 中我们可以这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">resource.request().onComplete &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] response <span class="keyword">in</span></span><br><span class="line">  <span class="keyword">guard</span> <span class="keyword">let</span> strongSelf = <span class="keyword">self</span> <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> model = strongSelf.updateModel(response)</span><br><span class="line">  strongSelf.updateUI(model)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不想使用 <code>strongSelf</code> 这个名字，想继续使用 <code>self</code>, 也可以直接这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">guard</span> <span class="keyword">let</span> `<span class="keyword">self</span>` = <span class="keyword">self</span> <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这样我们可以避免修改老代码时的 <code>self</code> 为 <code>strongSelf</code> 了。</p>
<h2 id="几种遍历方式"><a href="#几种遍历方式" class="headerlink" title="几种遍历方式"></a>几种遍历方式</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="number">_</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">3</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"Hello three times"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 带索引</span></span><br><span class="line"><span class="keyword">for</span> (index, person) <span class="keyword">in</span> attendeeList.enumerated() &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"\(person) is at position #\(index)"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每隔两个打印</span></span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">stride</span>(from: <span class="number">0</span>, to: <span class="number">5</span>, by: <span class="number">2</span>) &#123;</span><br><span class="line">  <span class="built_in">print</span>(index)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出： 0 2 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 倒叙</span></span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> (<span class="number">0</span>...<span class="number">3</span>).reversed() &#123;</span><br><span class="line">  <span class="built_in">print</span>(index)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：3 2 1 0</span></span><br></pre></td></tr></table></figure>
<h2 id="访问级别"><a href="#访问级别" class="headerlink" title="访问级别"></a>访问级别</h2><p>Swift 中的访问级别有以下<strong>五种</strong>：</p>
<ul>
<li><code>open</code>：公开权限, 最高的权限，可以被其他模块访问，继承及复写。</li>
<li><code>public</code>：公有访问权限，类或者类的公有属性或者公有方法可以从文件或者模块的任何地方进行访问。那么什么样才能成为一个模块呢？一个 App 就是一个模块，一个第三方 API，第三等方框架等都是一个完整的模块，这些模块如果要对外留有访问的属性或者方法，就应该使用 public 的访问权限。public 的权限在 Swift 3.0 后无法在其他模块被复写方法/属性或被继承。</li>
<li><code>fileprivate</code>：文件私有访问权限，被 fileprivate 修饰的类或者类的属性或方法可以在同一个物理文件中访问。如果超出该物理文件，那么有着 fileprivate 访问权限的类，属性和方法就不能被访问。</li>
<li><code>private</code>：私有访问权限，被 private 修饰的类或者类的属性或方法可以在同一个物理文件中的同一个类型（包含 extension）访问。如果超出该物理文件或不属于同一类型，那么有着 private 访问权限的属性和方法就不能被访问。</li>
<li><code>internal</code>： 顾名思义，internal 是内部的意思，即有着 internal 访问权限的属性和方法说明在模块内部可以访问，超出模块内部就不可被访问了。在 Swift 中默认就是 internal 的访问权限。</li>
</ul>
<h2 id="for-in-和-forEach-的区别"><a href="#for-in-和-forEach-的区别" class="headerlink" title="for in 和 forEach 的区别"></a>for in 和 forEach 的区别</h2><p><code>for in</code> 能使用 <code>return</code>、<code>break</code>、<code>continue</code> 关键字，<code>forEach</code> 不能使用 <code>break</code>、<code>continue</code> 关键字。<strong>它们的主要区别在于 <code>return</code> 关键字结果的不同：</strong></p>
<p>在 <code>for in</code> 中，<code>return</code> 会导致循环终止：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>]</span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> array &#123;</span><br><span class="line">    <span class="keyword">if</span> element == <span class="string">"3"</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(element)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>而 <code>forEach</code> 会跳过当前循环，完成剩余的循环：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>]</span><br><span class="line">array.forEach &#123; (element) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">if</span> element == <span class="string">"3"</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">print</span>(element)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<p><strong>这样看来，<code>forEach</code> 中的 <code>return</code> 关键字倒是有点类似 <code>for in</code> 中的 <code>continue</code> 了！</strong></p>
<h2 id="1.4.0"> 取消 asyncAfter 中延迟的事件 </h2>

<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> workItem = <span class="type">DispatchWorkItem</span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"test"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        <span class="comment">// Do any additional setup after loading the view, typically from a nib.</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">DispatchQueue</span>.main.asyncAfter(deadline: <span class="type">DispatchTime</span>.now() + <span class="number">3</span>, execute: workItem)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里点击取消之前延迟的事情</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">touchesBegan</span><span class="params">(<span class="number">_</span> touches: Set&lt;UITouch&gt;, with event: UIEvent?)</span></span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">print</span>(workItem.isCancelled ? <span class="string">"取消了"</span> : <span class="string">"未取消"</span>)</span><br><span class="line">        </span><br><span class="line">        workItem.cancel()</span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(workItem.isCancelled ? <span class="string">"取消了"</span> : <span class="string">"未取消"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line"><span class="comment">// 未取消</span></span><br><span class="line"><span class="comment">// 取消了</span></span><br></pre></td></tr></table></figure>
<h2 id="善用-exception-来避免多个协议"><a href="#善用-exception-来避免多个协议" class="headerlink" title="善用 exception 来避免多个协议"></a>善用 exception 来避免多个协议</h2><p>我们应该避免这种代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewController</span>: <span class="title">UIViewController</span>, <span class="title">UITableViewDataSource</span>, <span class="title">UIScrollViewDelegate</span> </span>&#123;</span><br><span class="line">  <span class="comment">// all methods</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应该采用下面这种形式：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyViewController</span>: <span class="title">UIViewController</span> </span>&#123;</span><br><span class="line">  <span class="comment">// class stuff here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: - UITableViewDataSource</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MyViewController</span>: <span class="title">UITableViewDataSource</span> </span>&#123;</span><br><span class="line">  <span class="comment">// table view data source methods</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: - UIScrollViewDelegate</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">MyViewController</span>: <span class="title">UIScrollViewDelegate</span> </span>&#123;</span><br><span class="line">  <span class="comment">// scroll view delegate methods</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多使用类型推断"><a href="#多使用类型推断" class="headerlink" title="多使用类型推断"></a>多使用类型推断</h2><p>避免下面这种代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> selector = #selector(<span class="type">ViewController</span>.viewDidLoad)</span><br><span class="line">view.backgroundColor = <span class="type">UIColor</span>.red</span><br><span class="line"><span class="keyword">let</span> toView = context.view(forKey: <span class="type">UITransitionContextViewKey</span>.to)</span><br><span class="line"><span class="keyword">let</span> view = <span class="type">UIView</span>(frame: <span class="type">CGRect</span>.zero)</span><br></pre></td></tr></table></figure>
<p>应该这样：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> selector = #selector(viewDidLoad)</span><br><span class="line">view.backgroundColor = .red</span><br><span class="line"><span class="keyword">let</span> toView = context.view(forKey: .to)</span><br><span class="line"><span class="keyword">let</span> view = <span class="type">UIView</span>(frame: .zero)</span><br></pre></td></tr></table></figure>
<h2 id="使用-autoclosure-使代码更加优雅"><a href="#使用-autoclosure-使代码更加优雅" class="headerlink" title="使用 @autoclosure 使代码更加优雅"></a>使用 @autoclosure 使代码更加优雅</h2><p>比如下面这种例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">and</span><span class="params">(<span class="number">_</span> l: Bool, <span class="number">_</span> r: <span class="params">()</span></span></span> -&gt; <span class="type">Bool</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> l <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br><span class="line">    <span class="keyword">return</span> r()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为第二个入参是个闭包，所以我们在使用时得这么写：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> events = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">if</span> and(!events.isEmpty, &#123; events[<span class="number">0</span>] &gt; <span class="number">10</span> &#125;) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二个参数被 <code>{}</code> 包着，看起来总是怪怪的。这时候我们可以使用 <code>@autoclosure</code> 标注来告诉编译器它应该将某个参数用闭包表达式包装起来：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">and</span><span class="params">(<span class="number">_</span> l: Bool, <span class="number">_</span> r:@autoclosure <span class="params">()</span></span></span> -&gt; <span class="type">Bool</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> l <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">false</span> &#125;</span><br><span class="line">    <span class="keyword">return</span> r()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们使用时就不用 <code>{}</code> 了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> events = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">if</span> and(!events.isEmpty, events[<span class="number">0</span>] &gt; <span class="number">10</span>) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="利用-Set-去重并保持顺序"><a href="#利用-Set-去重并保持顺序" class="headerlink" title="利用 Set 去重并保持顺序"></a>利用 Set 去重并保持顺序</h2><p>Set 集合<strong>可以去重，却无法保证顺序</strong>。这时候我们可以写个扩展方便我们使用：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Sequence</span> <span class="title">where</span> <span class="title">Element</span>: <span class="title">Hashable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">unique</span><span class="params">()</span></span> -&gt; [<span class="type">Element</span>] &#123;</span><br><span class="line">        <span class="keyword">var</span> seen: <span class="type">Set</span>&lt;<span class="type">Element</span>&gt; = []</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">filter</span>(&#123; element <span class="keyword">in</span></span><br><span class="line">            <span class="keyword">if</span> seen.<span class="built_in">contains</span>(element)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                seen.insert(element)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr =  [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">12</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">6</span>].unique()</span><br><span class="line"><span class="built_in">print</span>(arr)</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出： [1, 2, 3, 12, 4, 5, 6]</span></span><br></pre></td></tr></table></figure>
<h2 id="利用-contains-判断元素是否满足条件"><a href="#利用-contains-判断元素是否满足条件" class="headerlink" title="利用 contains 判断元素是否满足条件"></a>利用 contains 判断元素是否满足条件</h2><p>如果我们想更加高效的判断集合中所有元素是否<strong>都</strong>满足某个条件：<br>通常我们使用 contians 函数来判断集合中是否满足条件。但是 contians 正常情况下，<strong>一旦匹配到条件，默认是会提前退出</strong>，这样就会导致整个集合并没有全部匹配完。虽然我们可以使用 filter 函数，但是相对于前者，filter 会为了计数而创建一整个全新的数组，会有点慢。这种情况下，我们可以这么做：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Sequence</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">all</span><span class="params">(matching predicate: <span class="params">(Element)</span></span></span> -&gt; <span class="type">Bool</span>) -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !<span class="built_in">contains</span> &#123; !predicate($<span class="number">0</span>) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> xs = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line"><span class="keyword">let</span> t = xs.all &#123; $<span class="number">0</span> &gt; <span class="number">2</span> &#125;</span><br><span class="line"><span class="built_in">print</span>(t)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出： true</span></span><br></pre></td></tr></table></figure>
<h2 id="map、flatMap和compactMap-区别"><a href="#map、flatMap和compactMap-区别" class="headerlink" title="map、flatMap和compactMap 区别"></a>map、flatMap和compactMap 区别</h2><p>flatMap 相比于 map 有如下不同点：</p>
<ul>
<li>多维数组会执行<strong>降维</strong></li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]]</span><br><span class="line"><span class="keyword">let</span> temArr = arr.<span class="built_in">map</span>&#123; $<span class="number">0</span>.<span class="built_in">map</span> &#123; $<span class="number">0</span> * <span class="number">10</span>&#125; &#125;</span><br><span class="line"><span class="built_in">print</span>(temArr)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">let</span> tempArrFlat = arr.flatMap&#123; $<span class="number">0</span>.<span class="built_in">map</span> &#123; $<span class="number">0</span> * <span class="number">10</span>&#125; &#125;</span><br><span class="line"><span class="built_in">print</span>(tempArrFlat)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line">[[<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>], [<span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>]]</span><br><span class="line">[<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>, <span class="number">60</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>过滤 nil，强制解包</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">"A"</span>,<span class="string">"B"</span>,<span class="literal">nil</span>,<span class="string">"C"</span>]</span><br><span class="line"><span class="keyword">let</span> temArr = arr.<span class="built_in">map</span>&#123; $<span class="number">0</span> &#125;</span><br><span class="line"><span class="built_in">print</span>(temArr)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tempArrFlat = arr.flatMap&#123; $<span class="number">0</span> &#125;</span><br><span class="line">rint(tempArrFlat)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出： </span></span><br><span class="line">[<span class="type">Optional</span>(<span class="string">"A"</span>), <span class="type">Optional</span>(<span class="string">"B"</span>), <span class="literal">nil</span>, <span class="type">Optional</span>(<span class="string">"C"</span>)]</span><br><span class="line">[<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>compactMap 是 swift 4.1 后推出的用来替换 <del>flatMap</del> 的函数，功能类似：</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> tempArrC = arr.compactMap&#123; $<span class="number">0</span> &#125;</span><br><span class="line"><span class="built_in">print</span>(tempArrC)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line">[<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>]</span><br></pre></td></tr></table></figure>
</div><iframe src="/donate/?AliPayQR=/img/AliPay.png&amp;WeChatQR=/img/WechatPay.png&amp;GitHub=null&amp;BTCQR=null&amp;BTCKEY=null&amp;PayPal=null" style="overflow-x:hidden; overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;" frameborder="0" scrolling="no"></iframe><div class="tags"></div><div class="post-nav"><a class="pre" href="/2018/03/06/self_release/">聊聊 iOS 中的自释放</a><a class="next" href="/2017/11/06/responder_chain/">基于 ResponderChain 的对象交互方式</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'http://yoursite.com/2018/02/13/swift_tips/';
    this.page.identifier = '2018/02/13/swift_tips/';
    this.page.title = 'Swift 小知识点';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//leeeisok.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//leeeisok.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://leeeisok.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });
</script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Swift/">Swift</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/iOS/">iOS</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/总结/">总结</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/12/27/2018_questioning/">2018 年度总结</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/08/19/message_forward/">iOS 消息发送与转发详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/04/24/log_analysis/">iOS crash 日志堆栈解析</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/06/self_release/">聊聊 iOS 中的自释放</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/02/13/swift_tips/">Swift 小知识点</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/06/responder_chain/">基于 ResponderChain 的对象交互方式</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/09/06/list_optimize/">iOS 中关于列表滚动流畅方案的一些探讨</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//leeeisok.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2018 <a href="/." rel="nofollow">秃头披风侠.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>